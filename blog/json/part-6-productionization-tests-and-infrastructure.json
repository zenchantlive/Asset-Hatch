{
  "reward": {
    "type": "xlm"
  },
  "sourcedFromGithub": false,
  "githubAsSourceMeta": null,
  "isAnonymous": false,
  "coverImage": "",
  "autoGeneratedCover": "",
  "hasPolls": false,
  "totalPollVotes": 0,
  "upvotes": 0,
  "downvotes": 0,
  "untaggedFrom": [],
  "upvotedBy": [],
  "downvotedBy": [],
  "responses": [],
  "followers": [],
  "answeredByTarget": false,
  "inviters": [],
  "duplicatePosts": [],
  "hasReward": false,
  "bookmarkedIn": [],
  "similarPostIds": [],
  "reactionsByCurrentUser": [],
  "toc": [],
  "_id": "695af139b10cf08042f6dded",
  "createdAt": "2026-01-04T23:01:13.412Z",
  "updatedAt": "2026-01-04T23:12:54.276Z",
  "views": 3,
  "isActive": true,
  "hasLatex": true,
  "popularity": 7967.9216,
  "discussionScore": 0,
  "enableToc": false,
  "type": "story",
  "partOfPublication": true,
  "responseCount": 0,
  "replyCount": 0,
  "isFeatured": false,
  "isEngaging": false,
  "isDelisted": false,
  "isNotified": false,
  "numCollapsed": 0,
  "reactions": [],
  "totalReactions": 0,
  "totalReactionsByCurrentUser": 0,
  "isPinnedToBlog": false,
  "disableComments": false,
  "commentsPaused": false,
  "syncAlgolia": false,
  "numUniqueUsersWhoReacted": 0,
  "slugOverridden": true,
  "tweetOptions": {
    "enabled": false
  },
  "title": "Part 6: Productionization - Tests & Infrastructure",
  "cuid": "cmk0c5lj7000h02l1huqv5tcx",
  "dateAdded": "2026-01-04T23:01:13.411Z",
  "isCoverAttributionHidden": false,
  "stickCoverToBottom": false,
  "slug": "part-6-productionization-tests-and-infrastructure",
  "content": "<hr />\n<h2 id=\"heading-previously\"><strong>Previously:</strong></h2>\n<h3 id=\"heading-solved-the-hybrid-persistence-architecture-dexie-for-client-prisma-for-server-sync-between-them\">Solved the hybrid persistence architecture. Dexie for client, Prisma for server, sync between them.</h3>\n<p><strong>Now:</strong> Time to build the generation infrastructure and make this production-ready.</p>\n<h2 id=\"heading-the-test-first-pivot\">The Test-First Pivot</h2>\n<p>After two architectural crises (CopilotKit failure, IndexedDB in Node.js), I decided: <strong>no more surprises</strong>. Every API route gets integration tests <em>before</em> building complex features on top.</p>\n<h3 id=\"heading-jest-nextjs-16-configuration-hell\">Jest + Next.js 16 Configuration Hell</h3>\n<p><strong>Attempt 1:</strong></p>\n<pre><code class=\"lang-bash\">bun add -D jest @testing-library/react @testing-library/jest-dom\n</code></pre>\n<pre><code class=\"lang-javascript\"><span class=\"hljs-comment\">// jest.config.js</span>\n<span class=\"hljs-built_in\">module</span>.exports = {\n  <span class=\"hljs-attr\">testEnvironment</span>: <span class=\"hljs-string\">'jsdom'</span>, <span class=\"hljs-comment\">// For React component tests</span>\n};\n</code></pre>\n<p><strong>Run tests:</strong></p>\n<pre><code class=\"lang-markdown\">Error: Cannot find module 'server-only'\n  from node<span class=\"hljs-emphasis\">_modules/next/dist/client/components/headers.js</span>\n</code></pre>\n<p><strong>Problem:</strong> Next.js 16 has React Server Components. Some modules are <code>'use client'</code>, some are <code>'use server'</code>. Jest's single <code>testEnvironment</code> can't handle both.</p>\n<p><strong>Attempt 2: Environment per file</strong></p>\n<pre><code class=\"lang-javascript\"><span class=\"hljs-comment\">// jest.config.js</span>\n<span class=\"hljs-built_in\">module</span>.exports = {\n  <span class=\"hljs-attr\">testEnvironment</span>: <span class=\"hljs-string\">'node'</span>, <span class=\"hljs-comment\">// Default to node</span>\n  <span class=\"hljs-attr\">testMatch</span>: [\n    <span class=\"hljs-string\">'**/__tests__/**/*.test.ts'</span>,\n    <span class=\"hljs-string\">'**/__tests__/**/*.test.tsx'</span>,\n  ],\n};\n</code></pre>\n<pre><code class=\"lang-typescript\"><span class=\"hljs-comment\">// __tests__/components/QualitiesBar.test.tsx</span>\n<span class=\"hljs-comment\">/**\n * @jest-environment jsdom\n */</span>\n<span class=\"hljs-keyword\">import</span> { render } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@testing-library/react'</span>;\n<span class=\"hljs-comment\">// ...</span>\n</code></pre>\n<p><strong>Result:</strong> ‚úÖ Works! API routes use <code>node</code>, React components use <code>jsdom</code>.</p>\n<h3 id=\"heading-integration-test-pattern\">Integration Test Pattern</h3>\n<pre><code class=\"lang-typescript\"><span class=\"hljs-comment\">// __tests__/api/chat/route.test.ts</span>\n<span class=\"hljs-comment\">/**\n * @jest-environment node\n */</span>\n<span class=\"hljs-keyword\">import</span> { POST } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@/app/api/chat/route'</span>;\n<span class=\"hljs-keyword\">import</span> { prisma } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@/lib/prisma'</span>;\n\n<span class=\"hljs-comment\">// Mock external dependencies</span>\njest.mock(<span class=\"hljs-string\">'@/lib/prisma'</span>, <span class=\"hljs-function\">() =&gt;</span> ({\n  prisma: {\n    project: {\n      update: jest.fn(),\n      findUnique: jest.fn(),\n    },\n    memoryFile: {\n      upsert: jest.fn(),\n    },\n  },\n}));\n\ndescribe(<span class=\"hljs-string\">'POST /api/chat'</span>, <span class=\"hljs-function\">() =&gt;</span> {\n  beforeEach(<span class=\"hljs-function\">() =&gt;</span> {\n    jest.clearAllMocks();\n  });\n\n  it(<span class=\"hljs-string\">'updates quality when AI calls updateQuality tool'</span>, <span class=\"hljs-keyword\">async</span> () =&gt; {\n    <span class=\"hljs-keyword\">const</span> request = <span class=\"hljs-keyword\">new</span> Request(<span class=\"hljs-string\">'http://localhost:3000/api/chat'</span>, {\n      method: <span class=\"hljs-string\">'POST'</span>,\n      headers: { <span class=\"hljs-string\">'Content-Type'</span>: <span class=\"hljs-string\">'application/json'</span> },\n      body: <span class=\"hljs-built_in\">JSON</span>.stringify({\n        messages: [\n          { role: <span class=\"hljs-string\">'user'</span>, content: <span class=\"hljs-string\">'Set art style to pixel art'</span> },\n        ],\n        qualities: {},\n        projectId: <span class=\"hljs-string\">'test-project-id'</span>,\n      }),\n    });\n\n    (prisma.project.update <span class=\"hljs-keyword\">as</span> jest.Mock).mockResolvedValue({\n      id: <span class=\"hljs-string\">'test-project-id'</span>,\n      artStyle: <span class=\"hljs-string\">'Pixel Art'</span>,\n    });\n\n    <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> POST(request <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">any</span>);\n\n    expect(response.status).toBe(<span class=\"hljs-number\">200</span>);\n    expect(prisma.project.update).toHaveBeenCalledWith({\n      where: { id: <span class=\"hljs-string\">'test-project-id'</span> },\n      data: expect.objectContaining({\n        artStyle: <span class=\"hljs-string\">'Pixel Art'</span>,\n      }),\n    });\n  });\n\n  it(<span class=\"hljs-string\">'updates plan when AI calls updatePlan tool'</span>, <span class=\"hljs-keyword\">async</span> () =&gt; {\n    <span class=\"hljs-keyword\">const</span> planMarkdown = <span class=\"hljs-string\">'# Asset Plan\\n## Characters\\n- Farmer'</span>;\n\n    <span class=\"hljs-keyword\">const</span> request = <span class=\"hljs-keyword\">new</span> Request(<span class=\"hljs-string\">'http://localhost:3000/api/chat'</span>, {\n      method: <span class=\"hljs-string\">'POST'</span>,\n      body: <span class=\"hljs-built_in\">JSON</span>.stringify({\n        messages: [\n          { role: <span class=\"hljs-string\">'user'</span>, content: <span class=\"hljs-string\">'Show me a plan'</span> },\n        ],\n        projectId: <span class=\"hljs-string\">'test-project-id'</span>,\n      }),\n    });\n\n    (prisma.memoryFile.upsert <span class=\"hljs-keyword\">as</span> jest.Mock).mockResolvedValue({\n      id: <span class=\"hljs-string\">'file-id'</span>,\n      content: planMarkdown,\n    });\n\n    <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> POST(request <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">any</span>);\n\n    expect(prisma.memoryFile.upsert).toHaveBeenCalled();\n  });\n});\n</code></pre>\n<p><strong>Coverage:</strong></p>\n<ul>\n<li><p>‚úÖ <code>/api/chat</code> - Tool calling, quality updates, plan updates</p>\n</li>\n<li><p>‚úÖ <code>/api/analyze-style</code> - Style keyword extraction</p>\n</li>\n<li><p>‚úÖ <code>/api/generate</code> - Prompt building, OpenRouter integration</p>\n</li>\n<li><p>‚úÖ <code>lib/image-utils.ts</code> - Blob/base64, color extraction, and grid processing</p>\n</li>\n<li><p>‚úÖ <code>lib/openrouter-image.ts</code> - Flux.2 generation via OpenRouter API</p>\n</li>\n</ul>\n<p><strong>Total:</strong> 12 unit and integration tests across 5 critical logic files</p>\n<h2 id=\"heading-generation-infrastructure-the-p0-build\">Generation Infrastructure (The P0 Build)</h2>\n<p>With tests in place, I implemented the complete generation workflow:</p>\n<h3 id=\"heading-1-prompt-templates-by-asset-type\">1. Prompt Templates by Asset Type</h3>\n<pre><code class=\"lang-typescript\"><span class=\"hljs-comment\">// lib/prompt-templates.ts</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> CHARACTER_SPRITE_TEMPLATE = <span class=\"hljs-function\">(<span class=\"hljs-params\">\n  description: <span class=\"hljs-built_in\">string</span>,\n  qualities: Qualities,\n  styleKeywords: <span class=\"hljs-built_in\">string</span>\n</span>) =&gt;</span> {\n  <span class=\"hljs-comment\">// First 5 words carry highest weight in Flux.2</span>\n  <span class=\"hljs-keyword\">return</span> [\n    <span class=\"hljs-string\">`<span class=\"hljs-subst\">${qualities.art_style}</span> sprite of`</span>,    <span class=\"hljs-comment\">// Art style</span>\n    description,                             <span class=\"hljs-comment\">// Character details</span>\n    <span class=\"hljs-string\">`<span class=\"hljs-subst\">${qualities.perspective}</span> view,`</span>,       <span class=\"hljs-comment\">// Perspective</span>\n    <span class=\"hljs-string\">`<span class=\"hljs-subst\">${qualities.base_resolution}</span>,`</span>,        <span class=\"hljs-comment\">// Resolution</span>\n    styleKeywords,                           <span class=\"hljs-comment\">// Style anchor keywords</span>\n    qualities.mood,                          <span class=\"hljs-comment\">// Mood</span>\n    qualities.theme,                         <span class=\"hljs-comment\">// Theme</span>\n  ].filter(<span class=\"hljs-built_in\">Boolean</span>).join(<span class=\"hljs-string\">' '</span>);\n};\n\n<span class=\"hljs-comment\">// Examples for each asset type:</span>\n<span class=\"hljs-comment\">// - CHARACTER_SPRITE_TEMPLATE</span>\n<span class=\"hljs-comment\">// - ENVIRONMENT_TILESET_TEMPLATE</span>\n<span class=\"hljs-comment\">// - UI_ELEMENT_TEMPLATE</span>\n<span class=\"hljs-comment\">// - ICON_TEMPLATE</span>\n<span class=\"hljs-comment\">// - PROP_TEMPLATE</span>\n<span class=\"hljs-comment\">// - ANIMATION_SPRITESHEET_TEMPLATE</span>\n</code></pre>\n<p><strong>Why templates?</strong></p>\n<ul>\n<li><p>Word order matters (Flux.2 weighs first 5 words heaviest)</p>\n</li>\n<li><p>Consistency across all assets</p>\n</li>\n<li><p>Easy to A/B test prompt improvements</p>\n</li>\n</ul>\n<h3 id=\"heading-2-prompt-builder-with-priority-ordering\">2. Prompt Builder with Priority Ordering</h3>\n<pre><code class=\"lang-typescript\"><span class=\"hljs-comment\">// lib/prompt-builder.ts</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">buildAssetPrompt</span>(<span class=\"hljs-params\">\n  asset: ParsedAsset,\n  project: Project,\n  styleAnchor: StyleAnchor,\n  characterRegistry?: CharacterRegistry\n</span>): <span class=\"hljs-title\">string</span> </span>{\n  <span class=\"hljs-keyword\">const</span> qualities = extractQualities(project);\n\n  <span class=\"hljs-comment\">// Select template based on asset type</span>\n  <span class=\"hljs-keyword\">const</span> template = getTemplateForAssetType(asset.assetType);\n\n  <span class=\"hljs-comment\">// Build description</span>\n  <span class=\"hljs-keyword\">const</span> description = asset.assetType === <span class=\"hljs-string\">'character'</span> &amp;&amp; characterRegistry\n    ? <span class=\"hljs-string\">`<span class=\"hljs-subst\">${asset.name}</span> character with <span class=\"hljs-subst\">${characterRegistry.base_description}</span>`</span>\n    : asset.description;\n\n  <span class=\"hljs-comment\">// Generate prompt</span>\n  <span class=\"hljs-keyword\">const</span> prompt = template(description, qualities, styleAnchor.style_keywords);\n\n  <span class=\"hljs-comment\">// Validate length (Flux.2 limit: 256 tokens)</span>\n  <span class=\"hljs-keyword\">if</span> (prompt.split(<span class=\"hljs-string\">' '</span>).length &gt; <span class=\"hljs-number\">200</span>) {\n    <span class=\"hljs-built_in\">console</span>.warn(<span class=\"hljs-string\">'Prompt may exceed token limit:'</span>, prompt.length);\n  }\n\n  <span class=\"hljs-keyword\">return</span> prompt;\n}\n</code></pre>\n<h3 id=\"heading-3-plan-parser-composite-vs-granular\">3. Plan Parser (Composite vs Granular)</h3>\n<pre><code class=\"lang-typescript\"><span class=\"hljs-comment\">// lib/plan-parser.ts</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">parsePlan</span>(<span class=\"hljs-params\">\n  planMarkdown: <span class=\"hljs-built_in\">string</span>,\n  mode: 'composite' | 'granular' = 'composite'\n</span>): <span class=\"hljs-title\">ParsedAsset</span>[] </span>{\n  <span class=\"hljs-keyword\">const</span> lines = planMarkdown.split(<span class=\"hljs-string\">'\\n'</span>);\n  <span class=\"hljs-keyword\">const</span> assets: ParsedAsset[] = [];\n\n  <span class=\"hljs-keyword\">let</span> currentCategory: Category | <span class=\"hljs-literal\">null</span> = <span class=\"hljs-literal\">null</span>;\n\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> line <span class=\"hljs-keyword\">of</span> lines) {\n    <span class=\"hljs-comment\">// Parse headers: ## Characters</span>\n    <span class=\"hljs-keyword\">if</span> (line.startsWith(<span class=\"hljs-string\">'## '</span>)) {\n      currentCategory = extractCategory(line);\n      <span class=\"hljs-keyword\">continue</span>;\n    }\n\n    <span class=\"hljs-comment\">// Parse entities: - **Farmer** (Player character)</span>\n    <span class=\"hljs-keyword\">if</span> (line.startsWith(<span class=\"hljs-string\">'- **'</span>)) {\n      <span class=\"hljs-keyword\">const</span> match = line.match(<span class=\"hljs-regexp\">/- \\*\\*(.+?)\\*\\* \\((.+?)\\)/</span>);\n      <span class=\"hljs-keyword\">if</span> (!match) <span class=\"hljs-keyword\">continue</span>;\n\n      <span class=\"hljs-keyword\">const</span> [_, name, description] = match;\n\n      <span class=\"hljs-comment\">// Auto-detect asset type</span>\n      <span class=\"hljs-keyword\">const</span> assetType = inferAssetType(currentCategory, name, description);\n\n      <span class=\"hljs-comment\">// Handle animations</span>\n      <span class=\"hljs-keyword\">if</span> (description.includes(<span class=\"hljs-string\">'animation'</span>) || description.includes(<span class=\"hljs-string\">'frames'</span>)) {\n        <span class=\"hljs-keyword\">if</span> (mode === <span class=\"hljs-string\">'composite'</span>) {\n          <span class=\"hljs-comment\">// One sprite sheet with all frames</span>\n          assets.push({\n            name: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${name}</span> Sprite Sheet`</span>,\n            assetType: <span class=\"hljs-string\">'character-sprite-sheet'</span>,\n            category: currentCategory!,\n            description,\n            frames: extractFrameCount(description),\n          });\n        } <span class=\"hljs-keyword\">else</span> {\n          <span class=\"hljs-comment\">// Individual frames</span>\n          <span class=\"hljs-keyword\">const</span> frames = extractFrameCount(description);\n          <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; frames; i++) {\n            assets.push({\n              name: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${name}</span> Frame <span class=\"hljs-subst\">${i + <span class=\"hljs-number\">1</span>}</span>`</span>,\n              assetType: <span class=\"hljs-string\">'character-sprite'</span>,\n              category: currentCategory!,\n              description: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${description}</span> (frame <span class=\"hljs-subst\">${i + <span class=\"hljs-number\">1</span>}</span>)`</span>,\n            });\n          }\n        }\n      } <span class=\"hljs-keyword\">else</span> {\n        assets.push({\n          name,\n          assetType,\n          category: currentCategory!,\n          description,\n        });\n      }\n    }\n  }\n\n  <span class=\"hljs-keyword\">return</span> assets;\n}\n</code></pre>\n<p><strong>Why composite by default?</strong></p>\n<ul>\n<li><p>Assures consistency for AI-based game generation</p>\n</li>\n<li><p>Game engines expect sprite sheets</p>\n</li>\n<li><p>1 API call instead of 4 (cheaper, faster)</p>\n</li>\n<li><p>LLM-friendly (AI coding agents can see full sheet)</p>\n</li>\n</ul>\n<h3 id=\"heading-4-image-utilities\">4. Image Utilities</h3>\n<pre><code class=\"lang-typescript\"><span class=\"hljs-comment\">// lib/image-utils.ts</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">blobToBase64</span>(<span class=\"hljs-params\">blob: Blob</span>): <span class=\"hljs-title\">Promise</span>&lt;<span class=\"hljs-title\">string</span>&gt; </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> reader = <span class=\"hljs-keyword\">new</span> FileReader();\n    reader.onloadend = <span class=\"hljs-function\">() =&gt;</span> resolve(reader.result <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">string</span>);\n    reader.onerror = reject;\n    reader.readAsDataURL(blob);\n  });\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">base64ToBlob</span>(<span class=\"hljs-params\">base64: <span class=\"hljs-built_in\">string</span></span>): <span class=\"hljs-title\">Promise</span>&lt;<span class=\"hljs-title\">Blob</span>&gt; </span>{\n  <span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-keyword\">await</span> fetch(base64);\n  <span class=\"hljs-keyword\">return</span> res.blob();\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">extractColorPalette</span>(<span class=\"hljs-params\">imageBlob: Blob</span>): <span class=\"hljs-title\">Promise</span>&lt;<span class=\"hljs-title\">string</span>[]&gt; </span>{\n  <span class=\"hljs-keyword\">const</span> img = <span class=\"hljs-keyword\">new</span> Image();\n  img.src = URL.createObjectURL(imageBlob);\n\n  <span class=\"hljs-keyword\">await</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">resolve</span> =&gt;</span> (img.onload = resolve));\n\n  <span class=\"hljs-keyword\">const</span> canvas = <span class=\"hljs-built_in\">document</span>.createElement(<span class=\"hljs-string\">'canvas'</span>);\n  <span class=\"hljs-keyword\">const</span> ctx = canvas.getContext(<span class=\"hljs-string\">'2d'</span>)!;\n\n  canvas.width = img.width;\n  canvas.height = img.height;\n  ctx.drawImage(img, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>);\n\n  <span class=\"hljs-keyword\">const</span> imageData = ctx.getImageData(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, canvas.width, canvas.height);\n  <span class=\"hljs-keyword\">const</span> pixels = imageData.data;\n\n  <span class=\"hljs-comment\">// Simple color quantization (production would use ColorThief)</span>\n  <span class=\"hljs-keyword\">const</span> colors = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>&lt;<span class=\"hljs-built_in\">string</span>, <span class=\"hljs-built_in\">number</span>&gt;();\n\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; pixels.length; i += <span class=\"hljs-number\">4</span>) {\n    <span class=\"hljs-keyword\">const</span> r = pixels[i];\n    <span class=\"hljs-keyword\">const</span> g = pixels[i + <span class=\"hljs-number\">1</span>];\n    <span class=\"hljs-keyword\">const</span> b = pixels[i + <span class=\"hljs-number\">2</span>];\n    <span class=\"hljs-keyword\">const</span> hex = <span class=\"hljs-string\">`#<span class=\"hljs-subst\">${r.toString(<span class=\"hljs-number\">16</span>).padStart(<span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">'0'</span>)}</span><span class=\"hljs-subst\">${g.toString(<span class=\"hljs-number\">16</span>).padStart(<span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">'0'</span>)}</span><span class=\"hljs-subst\">${b.toString(<span class=\"hljs-number\">16</span>).padStart(<span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">'0'</span>)}</span>`</span>;\n\n    colors.set(hex, (colors.get(hex) || <span class=\"hljs-number\">0</span>) + <span class=\"hljs-number\">1</span>);\n  }\n\n  <span class=\"hljs-comment\">// Return top 8 colors by frequency</span>\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Array</span>.from(colors.entries())\n    .sort(<span class=\"hljs-function\">(<span class=\"hljs-params\">a, b</span>) =&gt;</span> b[<span class=\"hljs-number\">1</span>] - a[<span class=\"hljs-number\">1</span>])\n    .slice(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">8</span>)\n    .map(<span class=\"hljs-function\">(<span class=\"hljs-params\">[hex]</span>) =&gt;</span> hex);\n}\n</code></pre>\n<h3 id=\"heading-5-generation-api-route\">5. Generation API Route</h3>\n<pre><code class=\"lang-typescript\"><span class=\"hljs-comment\">// app/api/generate/route.ts</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">POST</span>(<span class=\"hljs-params\">req: Request</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> { projectId, assetId } = <span class=\"hljs-keyword\">await</span> req.json();\n\n  <span class=\"hljs-comment\">// 1. Load context from Prisma (server-side)</span>\n  <span class=\"hljs-keyword\">const</span> project = <span class=\"hljs-keyword\">await</span> prisma.project.findUnique({ where: { id: projectId } });\n  <span class=\"hljs-keyword\">const</span> styleAnchor = <span class=\"hljs-keyword\">await</span> prisma.styleAnchor.findFirst({ where: { projectId } });\n  <span class=\"hljs-keyword\">const</span> planFile = <span class=\"hljs-keyword\">await</span> prisma.memoryFile.findFirst({\n    where: { projectId, fileName: <span class=\"hljs-string\">'entities.json'</span> },\n  });\n\n  <span class=\"hljs-keyword\">const</span> plan = parsePlan(planFile.content);\n  <span class=\"hljs-keyword\">const</span> asset = plan.find(<span class=\"hljs-function\"><span class=\"hljs-params\">a</span> =&gt;</span> a.id === assetId);\n\n  <span class=\"hljs-comment\">// 2. Build prompt</span>\n  <span class=\"hljs-keyword\">const</span> prompt = buildAssetPrompt(asset, project, styleAnchor);\n\n  <span class=\"hljs-comment\">// 3. Generate with Flux.2</span>\n  <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> fetch(<span class=\"hljs-string\">'https://openrouter.ai/api/v1/images/generations'</span>, {\n    method: <span class=\"hljs-string\">'POST'</span>,\n    headers: {\n      <span class=\"hljs-string\">'Authorization'</span>: <span class=\"hljs-string\">`Bearer <span class=\"hljs-subst\">${process.env.OPENROUTER_API_KEY}</span>`</span>,\n      <span class=\"hljs-string\">'Content-Type'</span>: <span class=\"hljs-string\">'application/json'</span>,\n    },\n    body: <span class=\"hljs-built_in\">JSON</span>.stringify({\n      model: <span class=\"hljs-string\">'black-forest-labs/flux.2-dev'</span>,\n      prompt,\n      images: [styleAnchor.reference_image_base64], <span class=\"hljs-comment\">// Style anchor!</span>\n      n: <span class=\"hljs-number\">1</span>,\n      size: project.baseResolution || <span class=\"hljs-string\">'1024x1024'</span>,\n    }),\n  });\n\n  <span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-keyword\">await</span> response.json();\n  <span class=\"hljs-keyword\">const</span> imageUrl = data.data[<span class=\"hljs-number\">0</span>].url;\n\n  <span class=\"hljs-comment\">// 4. Download and save</span>\n  <span class=\"hljs-keyword\">const</span> imageBlob = <span class=\"hljs-keyword\">await</span> fetch(imageUrl).then(<span class=\"hljs-function\"><span class=\"hljs-params\">r</span> =&gt;</span> r.blob());\n\n  <span class=\"hljs-keyword\">await</span> prisma.generatedAsset.create({\n    data: {\n      projectId,\n      assetId,\n      image_blob: Buffer.from(<span class=\"hljs-keyword\">await</span> imageBlob.arrayBuffer()),\n      prompt_used: prompt,\n      status: <span class=\"hljs-string\">'generated'</span>,\n      generation_metadata: <span class=\"hljs-built_in\">JSON</span>.stringify({\n        model: <span class=\"hljs-string\">'flux.2-dev'</span>,\n        seed: data.data[<span class=\"hljs-number\">0</span>].seed,\n        cost: calculateCost(project.baseResolution),\n      }),\n    },\n  });\n\n  <span class=\"hljs-keyword\">return</span> Response.json({ success: <span class=\"hljs-literal\">true</span>, assetId });\n}\n</code></pre>\n<h4 id=\"heading-6-style-anchor-integration-flux2-consistency\">6. Style Anchor Integration (Flux.2 Consistency)</h4>\n<p>The biggest challenge in AI image generation is consistency. If you generate a hero and then a monster, they often look like they belong to different games. We solved this using <strong>Style Anchors</strong>.</p>\n<p>When generating assets, we pass the project's style anchor image and extracted keywords to the <strong>Flux.2</strong> model. This \"anchors\" the model to the specific aesthetic, palette, and perspective of the approved reference image.</p>\n<h3 id=\"heading-7-explicit-decision-individual-vs-batch-generation\">7. Explicit Decision: Individual vs. Batch Generation</h3>\n<p>Mid-implementation, I hit a philosophical crossroad. Do I just hit \"Generate All\" and let the AI build everything in the background?</p>\n<p><strong>I chose Individual Generation.</strong></p>\n<p>Why? Because game development is iterative. You need to see if the AI understands the \"Farmer\" character before you generate \"Farmer - Walking Animation.\" By adding an explicit <strong>Approval Workflow</strong>, we prevent wasting API credits on misaligned assets.</p>\n<h3 id=\"heading-8-asset-approval-system-the-user-pivot\">8. Asset Approval System (The User Pivot)</h3>\n<p>User feedback (well, my own dog-fooding) led to a more interactive flow. Every generation now lands in an \"Awaiting Approval\" queue</p>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1767567546781/e915437b-f039-43f3-8526-37479355f76c.png\" alt class=\"image--center mx-auto\" /></p>\n<p>.</p>\n<pre><code class=\"lang-typescript\"><span class=\"hljs-comment\">// components/generation/AssetApprovalCard.tsx</span>\n<span class=\"hljs-comment\">// Features a large preview, metadata, and big Approve/Reject buttons at the top.</span>\n<span class=\"hljs-comment\">// Approval converts the base64 preview into a persistent Blob stored in Dexie.</span>\n</code></pre>\n<hr />\n<h2 id=\"heading-the-production-workflow-filespanel-amp-assetspanel\">The Production Workflow: FilesPanel &amp; AssetsPanel</h2>\n<p>Generation isn't just about calling an API; it's about managing a pipeline. We implemented two distinct panels:</p>\n<ol>\n<li><p><strong>FilesPanel</strong>: For project source files (plans, style drafts, character registries).</p>\n</li>\n<li><p><strong>AssetsPanel</strong>: A dedicated library for all <em>approved</em> generated assets.</p>\n</li>\n</ol>\n<h3 id=\"heading-features-of-the-assetspanel\">Features of the AssetsPanel:</h3>\n<ul>\n<li><p><strong>Grid Layout</strong>: A sleek 2-column grid showing thumbnails of every approved sprite.</p>\n</li>\n<li><p><strong>Detail View</strong>: Full-screen preview with complete metadata (seed, model, prompt used).</p>\n</li>\n<li><p><strong>Regeneration</strong>: Found a bug? Edit the prompt and regenerate directly from the panel.</p>\n</li>\n</ul>\n<h2 id=\"heading-the-aesthetic-shift-premium-typography\">The Aesthetic Shift: Premium Typography</h2>\n<p>As we moved into production, the default \"developer\" look (Inter everywhere) felt too clinical for a game dev tool.</p>\n<p>I updated the entire design system to a \"Premium Developer Blog\" aesthetic:</p>\n<ul>\n<li><p><strong>Headings</strong>: Serif (<strong>Playfair Display</strong>) for a sophisticated, editorial feel.</p>\n</li>\n<li><p><strong>Body</strong>: Clean Sans-serif (<strong>Inter</strong>) for maximum readability.</p>\n</li>\n<li><p><strong>Accents</strong>: Aurora gradients and glassmorphism elements to maintain the \"cosmic\" vibe.</p>\n</li>\n</ul>\n<hr />\n<h2 id=\"heading-multi-mode-planning-ui\">Multi-Mode Planning UI</h2>\n<p>One last architectural decision: <strong>Keep users in one page, switch modes</strong> instead of navigating between separate pages.</p>\n<pre><code class=\"lang-markdown\">‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ [Plan] [Style] [Generation]  üìÑ Files [‚ñº] ‚îÇ ‚Üê Tabs\n‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n‚îÇ                ‚îÇ                           ‚îÇ\n‚îÇ  Chat (Left)   ‚îÇ   Right Panel (Mode)      ‚îÇ\n‚îÇ                ‚îÇ                           ‚îÇ\n‚îÇ  - User msgs   ‚îÇ   Plan Mode:              ‚îÇ\n‚îÇ  - AI msgs     ‚îÇ   ‚îî‚îÄ Markdown preview     ‚îÇ\n‚îÇ  - Tools       ‚îÇ                           ‚îÇ\n‚îÇ                ‚îÇ   Style Mode:             ‚îÇ\n‚îÇ  (Persists     ‚îÇ   ‚îî‚îÄ Image upload        ‚îÇ\n‚îÇ   across       ‚îÇ   ‚îî‚îÄ Keyword editor       ‚îÇ\n‚îÇ   modes)       ‚îÇ   ‚îî‚îÄ Color palette        ‚îÇ\n‚îÇ                ‚îÇ                           ‚îÇ\n‚îÇ                ‚îÇ   Generation Mode:        ‚îÇ\n‚îÇ                ‚îÇ   ‚îî‚îÄ Asset queue          ‚îÇ\n‚îÇ                ‚îÇ   ‚îî‚îÄ Progress tracking    ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n</code></pre>\n<p><strong>Why?</strong></p>\n<ul>\n<li><p>Consistent UX (don't lose chat context)</p>\n</li>\n<li><p>Natural workflow (continue conversation across phases)</p>\n</li>\n<li><p>No page transitions (faster, smoother)</p>\n</li>\n<li><p>File menu accessible (see saved files anytime)</p>\n</li>\n</ul>\n<p><strong>Implementation:</strong></p>\n<pre><code class=\"lang-typescript\"><span class=\"hljs-comment\">// app/project/[id]/planning/page.tsx</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">PlanningPage</span>(<span class=\"hljs-params\">{ params }: { params: { id: <span class=\"hljs-built_in\">string</span> } }</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> [mode, setMode] = useState&lt;<span class=\"hljs-string\">'plan'</span> | <span class=\"hljs-string\">'style'</span> | <span class=\"hljs-string\">'generation'</span>&gt;(<span class=\"hljs-string\">'plan'</span>);\n\n  <span class=\"hljs-keyword\">return</span> (\n    &lt;div className=<span class=\"hljs-string\">\"grid grid-cols-2 gap-4\"</span>&gt;\n      {<span class=\"hljs-comment\">/* Left: Chat (always visible) */</span>}\n      &lt;ChatInterface projectId={params.id} /&gt;\n\n      {<span class=\"hljs-comment\">/* Right: Mode-specific panel */</span>}\n      &lt;div&gt;\n        &lt;Tabs value={mode} onValueChange={setMode}&gt;\n          &lt;TabsList&gt;\n            &lt;TabsTrigger value=<span class=\"hljs-string\">\"plan\"</span>&gt;Plan&lt;/TabsTrigger&gt;\n            &lt;TabsTrigger value=<span class=\"hljs-string\">\"style\"</span>&gt;Style&lt;/TabsTrigger&gt;\n            &lt;TabsTrigger value=<span class=\"hljs-string\">\"generation\"</span>&gt;Generation&lt;/TabsTrigger&gt;\n          &lt;/TabsList&gt;\n        &lt;/Tabs&gt;\n\n        {mode === <span class=\"hljs-string\">'plan'</span> &amp;&amp; &lt;PlanPreview /&gt;}\n        {mode === <span class=\"hljs-string\">'style'</span> &amp;&amp; &lt;StyleAnchorEditor /&gt;}\n        {mode === <span class=\"hljs-string\">'generation'</span> &amp;&amp; &lt;GenerationQueue /&gt;}\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>\n<h2 id=\"heading-the-results\">The Results</h2>\n<p><strong>Results Update (Dec 28):</strong></p>\n<ul>\n<li><p><strong>Tests</strong>: 15 unit and integration tests (100% coverage on core generation logic).</p>\n</li>\n<li><p><strong>Workflow</strong>: 100% functional individual generation ‚Üí approval ‚Üí persistent storage flow.</p>\n</li>\n<li><p><strong>UI</strong>: Premium typography integration complete. FilesPanel and AssetsPanel active.</p>\n</li>\n<li><p><strong>Performance</strong>: Flux.2 generation averaging ~6-8s via OpenRouter.</p>\n</li>\n</ul>\n<blockquote>\n<p>[!NOTE] While the generation logic was solid, we soon discovered critical security gaps in our API endpoints. We dive into the audit and hardening process in the next post.</p>\n</blockquote>\n<p><strong>Commits:</strong></p>\n<pre><code class=\"lang-bash\">commit a12bc3d - feat(generation): implement individual asset generation workflow and approval system\ncommit f4e5d6c - feat(ui): refine typography to Playfair Display / Inter\ncommit f01953c - feat(generation): fix plan loading 404\ncommit bea7089 - feat(style-anchor): implement Flux.2 image generation via OpenRouter\ncommit 475030a - feat(ui): implement FilesPanel and AssetsPanel <span class=\"hljs-keyword\">for</span> asset management\ncommit a4846e7 - Complete P0 generation infrastructure\ncommit bb2833b - Add plan parser and multi-mode planning page\n</code></pre>\n<hr />\n<h2 id=\"heading-what-i-learned\">What I Learned</h2>\n<p><strong>1. Tests prevent architecture surprises</strong></p>\n<p>After CopilotKit and IndexedDB failures, tests gave confidence each piece worked before building on it.</p>\n<p><strong>2. Prompt engineering is software engineering</strong></p>\n<p>Templates, priority ordering, token limits‚Äîit's not just \"vibes,\" it's architecture.</p>\n<p><strong>3. Word order matters in image models</strong></p>\n<p>Flux.2 weighs first 5 words heaviest. <code>\"pixel art sprite of farmer\"</code> beats <code>\"a farmer sprite in pixel art style\"</code>.</p>\n<p><strong>4. Composite &gt; Granular by default</strong></p>\n<p>Game devs expect sprite sheets. LLMs can see full sheets better. Fewer API calls.</p>\n<p><strong>5. Style anchors are critical</strong></p>\n<p>Without reference images, every asset looks different. With them, consistency jumps dramatically.</p>\n<p><strong>6. Multi-mode beats multi-page</strong></p>\n<p>Keeping users in one context with mode switching is smoother than full-page navigations.</p>\n<p><strong>7. Individual Approval &gt; Batch Fire-and-Forget</strong></p>\n<p>The quality gate of a human clicking \"Approve\" is the difference between a project of 50 random images and a cohesive game asset library.</p>\n<hr />\n<h2 id=\"heading-coming-next\">Coming Next</h2>\n<p>In <a target=\"_blank\" href=\"07-hardening-battle-testing-the-api.md\">Part 7: Hardening</a>, we move beyond \"it works\" to \"it's safe\".</p>\n<p>What happens when an automated security bot audits your AI-generated code? We find unauthenticated endpoints, race conditions, and error leaks‚Äîand fix them all.</p>\n<p><strong>Spoiler:</strong> AI is a great coder, but it's not a security auditor (yet).</p>\n<hr />\n<p><strong>Commit References:</strong></p>\n<ul>\n<li><p><code>a4846e7</code> - Complete P0 generation infrastructure implementation</p>\n</li>\n<li><p><code>bb2833b</code> - Add plan parser and multi-mode planning page</p>\n</li>\n<li><p><code>f401d5a</code> - Add style phase AI tools and integration</p>\n</li>\n<li><p><code>0345fda</code> - Complete core AI integration</p>\n</li>\n</ul>\n<p><strong>Files Created:</strong></p>\n<ul>\n<li><p><code>/components/generation/AssetApprovalCard.tsx</code> - Per-asset UI</p>\n</li>\n<li><p><code>/components/ui/AssetsPanel.tsx</code> - Library management</p>\n</li>\n<li><p><code>/lib/prompt-templates.ts</code> - 6 asset-type templates</p>\n</li>\n<li><p><code>/lib/prompt-builder.ts</code> - Priority-ordered generation</p>\n</li>\n<li><p><code>/lib/plan-parser.ts</code> - Markdown ‚Üí ParsedAsset[]</p>\n</li>\n<li><p><code>/lib/image-utils.ts</code> - Blob/base64, color extraction</p>\n</li>\n<li><p><code>/app/api/generate/route.ts</code> - Generation endpoint</p>\n</li>\n<li><p><code>/__tests__/**/*.test.ts</code> - 12+ integration tests</p>\n</li>\n</ul>\n<p><strong>Total Lines Added:</strong> ~3,450</p>\n<hr />\n<p><strong>Previous:</strong> <a target=\"_blank\" href=\"05-the-architecture-hybrid-persistence.md\">‚Üê Part 5: The Architecture</a><strong>Next:</strong> <a target=\"_blank\" href=\"07-hardening-battle-testing-the-api.md\">Part 7: Hardening ‚Üí</a></p>\n",
  "contentMarkdown": "---\n\n## **Previously:**\n\n### Solved the hybrid persistence architecture. Dexie for client, Prisma for server, sync between them.\n\n**Now:** Time to build the generation infrastructure and make this production-ready.\n\n## The Test-First Pivot\n\nAfter two architectural crises (CopilotKit failure, IndexedDB in Node.js), I decided: **no more surprises**. Every API route gets integration tests *before* building complex features on top.\n\n### Jest + Next.js 16 Configuration Hell\n\n**Attempt 1:**\n\n```bash\nbun add -D jest @testing-library/react @testing-library/jest-dom\n```\n\n```javascript\n// jest.config.js\nmodule.exports = {\n  testEnvironment: 'jsdom', // For React component tests\n};\n```\n\n**Run tests:**\n\n```markdown\nError: Cannot find module 'server-only'\n  from node_modules/next/dist/client/components/headers.js\n```\n\n**Problem:** Next.js 16 has React Server Components. Some modules are `'use client'`, some are `'use server'`. Jest's single `testEnvironment` can't handle both.\n\n**Attempt 2: Environment per file**\n\n```javascript\n// jest.config.js\nmodule.exports = {\n  testEnvironment: 'node', // Default to node\n  testMatch: [\n    '**/__tests__/**/*.test.ts',\n    '**/__tests__/**/*.test.tsx',\n  ],\n};\n```\n\n```typescript\n// __tests__/components/QualitiesBar.test.tsx\n/**\n * @jest-environment jsdom\n */\nimport { render } from '@testing-library/react';\n// ...\n```\n\n**Result:** ‚úÖ Works! API routes use `node`, React components use `jsdom`.\n\n### Integration Test Pattern\n\n```typescript\n// __tests__/api/chat/route.test.ts\n/**\n * @jest-environment node\n */\nimport { POST } from '@/app/api/chat/route';\nimport { prisma } from '@/lib/prisma';\n\n// Mock external dependencies\njest.mock('@/lib/prisma', () => ({\n  prisma: {\n    project: {\n      update: jest.fn(),\n      findUnique: jest.fn(),\n    },\n    memoryFile: {\n      upsert: jest.fn(),\n    },\n  },\n}));\n\ndescribe('POST /api/chat', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  it('updates quality when AI calls updateQuality tool', async () => {\n    const request = new Request('http://localhost:3000/api/chat', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        messages: [\n          { role: 'user', content: 'Set art style to pixel art' },\n        ],\n        qualities: {},\n        projectId: 'test-project-id',\n      }),\n    });\n\n    (prisma.project.update as jest.Mock).mockResolvedValue({\n      id: 'test-project-id',\n      artStyle: 'Pixel Art',\n    });\n\n    const response = await POST(request as any);\n\n    expect(response.status).toBe(200);\n    expect(prisma.project.update).toHaveBeenCalledWith({\n      where: { id: 'test-project-id' },\n      data: expect.objectContaining({\n        artStyle: 'Pixel Art',\n      }),\n    });\n  });\n\n  it('updates plan when AI calls updatePlan tool', async () => {\n    const planMarkdown = '# Asset Plan\\n## Characters\\n- Farmer';\n\n    const request = new Request('http://localhost:3000/api/chat', {\n      method: 'POST',\n      body: JSON.stringify({\n        messages: [\n          { role: 'user', content: 'Show me a plan' },\n        ],\n        projectId: 'test-project-id',\n      }),\n    });\n\n    (prisma.memoryFile.upsert as jest.Mock).mockResolvedValue({\n      id: 'file-id',\n      content: planMarkdown,\n    });\n\n    const response = await POST(request as any);\n\n    expect(prisma.memoryFile.upsert).toHaveBeenCalled();\n  });\n});\n```\n\n**Coverage:**\n\n* ‚úÖ `/api/chat` - Tool calling, quality updates, plan updates\n    \n* ‚úÖ `/api/analyze-style` - Style keyword extraction\n    \n* ‚úÖ `/api/generate` - Prompt building, OpenRouter integration\n    \n* ‚úÖ `lib/image-utils.ts` - Blob/base64, color extraction, and grid processing\n    \n* ‚úÖ `lib/openrouter-image.ts` - Flux.2 generation via OpenRouter API\n    \n\n**Total:** 12 unit and integration tests across 5 critical logic files\n\n## Generation Infrastructure (The P0 Build)\n\nWith tests in place, I implemented the complete generation workflow:\n\n### 1\\. Prompt Templates by Asset Type\n\n```typescript\n// lib/prompt-templates.ts\nexport const CHARACTER_SPRITE_TEMPLATE = (\n  description: string,\n  qualities: Qualities,\n  styleKeywords: string\n) => {\n  // First 5 words carry highest weight in Flux.2\n  return [\n    `${qualities.art_style} sprite of`,    // Art style\n    description,                             // Character details\n    `${qualities.perspective} view,`,       // Perspective\n    `${qualities.base_resolution},`,        // Resolution\n    styleKeywords,                           // Style anchor keywords\n    qualities.mood,                          // Mood\n    qualities.theme,                         // Theme\n  ].filter(Boolean).join(' ');\n};\n\n// Examples for each asset type:\n// - CHARACTER_SPRITE_TEMPLATE\n// - ENVIRONMENT_TILESET_TEMPLATE\n// - UI_ELEMENT_TEMPLATE\n// - ICON_TEMPLATE\n// - PROP_TEMPLATE\n// - ANIMATION_SPRITESHEET_TEMPLATE\n```\n\n**Why templates?**\n\n* Word order matters (Flux.2 weighs first 5 words heaviest)\n    \n* Consistency across all assets\n    \n* Easy to A/B test prompt improvements\n    \n\n### 2\\. Prompt Builder with Priority Ordering\n\n```typescript\n// lib/prompt-builder.ts\nexport function buildAssetPrompt(\n  asset: ParsedAsset,\n  project: Project,\n  styleAnchor: StyleAnchor,\n  characterRegistry?: CharacterRegistry\n): string {\n  const qualities = extractQualities(project);\n\n  // Select template based on asset type\n  const template = getTemplateForAssetType(asset.assetType);\n\n  // Build description\n  const description = asset.assetType === 'character' && characterRegistry\n    ? `${asset.name} character with ${characterRegistry.base_description}`\n    : asset.description;\n\n  // Generate prompt\n  const prompt = template(description, qualities, styleAnchor.style_keywords);\n\n  // Validate length (Flux.2 limit: 256 tokens)\n  if (prompt.split(' ').length > 200) {\n    console.warn('Prompt may exceed token limit:', prompt.length);\n  }\n\n  return prompt;\n}\n```\n\n### 3\\. Plan Parser (Composite vs Granular)\n\n```typescript\n// lib/plan-parser.ts\nexport function parsePlan(\n  planMarkdown: string,\n  mode: 'composite' | 'granular' = 'composite'\n): ParsedAsset[] {\n  const lines = planMarkdown.split('\\n');\n  const assets: ParsedAsset[] = [];\n\n  let currentCategory: Category | null = null;\n\n  for (const line of lines) {\n    // Parse headers: ## Characters\n    if (line.startsWith('## ')) {\n      currentCategory = extractCategory(line);\n      continue;\n    }\n\n    // Parse entities: - **Farmer** (Player character)\n    if (line.startsWith('- **')) {\n      const match = line.match(/- \\*\\*(.+?)\\*\\* \\((.+?)\\)/);\n      if (!match) continue;\n\n      const [_, name, description] = match;\n\n      // Auto-detect asset type\n      const assetType = inferAssetType(currentCategory, name, description);\n\n      // Handle animations\n      if (description.includes('animation') || description.includes('frames')) {\n        if (mode === 'composite') {\n          // One sprite sheet with all frames\n          assets.push({\n            name: `${name} Sprite Sheet`,\n            assetType: 'character-sprite-sheet',\n            category: currentCategory!,\n            description,\n            frames: extractFrameCount(description),\n          });\n        } else {\n          // Individual frames\n          const frames = extractFrameCount(description);\n          for (let i = 0; i < frames; i++) {\n            assets.push({\n              name: `${name} Frame ${i + 1}`,\n              assetType: 'character-sprite',\n              category: currentCategory!,\n              description: `${description} (frame ${i + 1})`,\n            });\n          }\n        }\n      } else {\n        assets.push({\n          name,\n          assetType,\n          category: currentCategory!,\n          description,\n        });\n      }\n    }\n  }\n\n  return assets;\n}\n```\n\n**Why composite by default?**\n\n* Assures consistency for AI-based game generation\n    \n* Game engines expect sprite sheets\n    \n* 1 API call instead of 4 (cheaper, faster)\n    \n* LLM-friendly (AI coding agents can see full sheet)\n    \n\n### 4\\. Image Utilities\n\n```typescript\n// lib/image-utils.ts\nexport async function blobToBase64(blob: Blob): Promise<string> {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onloadend = () => resolve(reader.result as string);\n    reader.onerror = reject;\n    reader.readAsDataURL(blob);\n  });\n}\n\nexport async function base64ToBlob(base64: string): Promise<Blob> {\n  const res = await fetch(base64);\n  return res.blob();\n}\n\nexport async function extractColorPalette(imageBlob: Blob): Promise<string[]> {\n  const img = new Image();\n  img.src = URL.createObjectURL(imageBlob);\n\n  await new Promise(resolve => (img.onload = resolve));\n\n  const canvas = document.createElement('canvas');\n  const ctx = canvas.getContext('2d')!;\n\n  canvas.width = img.width;\n  canvas.height = img.height;\n  ctx.drawImage(img, 0, 0);\n\n  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n  const pixels = imageData.data;\n\n  // Simple color quantization (production would use ColorThief)\n  const colors = new Map<string, number>();\n\n  for (let i = 0; i < pixels.length; i += 4) {\n    const r = pixels[i];\n    const g = pixels[i + 1];\n    const b = pixels[i + 2];\n    const hex = `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;\n\n    colors.set(hex, (colors.get(hex) || 0) + 1);\n  }\n\n  // Return top 8 colors by frequency\n  return Array.from(colors.entries())\n    .sort((a, b) => b[1] - a[1])\n    .slice(0, 8)\n    .map(([hex]) => hex);\n}\n```\n\n### 5\\. Generation API Route\n\n```typescript\n// app/api/generate/route.ts\nexport async function POST(req: Request) {\n  const { projectId, assetId } = await req.json();\n\n  // 1. Load context from Prisma (server-side)\n  const project = await prisma.project.findUnique({ where: { id: projectId } });\n  const styleAnchor = await prisma.styleAnchor.findFirst({ where: { projectId } });\n  const planFile = await prisma.memoryFile.findFirst({\n    where: { projectId, fileName: 'entities.json' },\n  });\n\n  const plan = parsePlan(planFile.content);\n  const asset = plan.find(a => a.id === assetId);\n\n  // 2. Build prompt\n  const prompt = buildAssetPrompt(asset, project, styleAnchor);\n\n  // 3. Generate with Flux.2\n  const response = await fetch('https://openrouter.ai/api/v1/images/generations', {\n    method: 'POST',\n    headers: {\n      'Authorization': `Bearer ${process.env.OPENROUTER_API_KEY}`,\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      model: 'black-forest-labs/flux.2-dev',\n      prompt,\n      images: [styleAnchor.reference_image_base64], // Style anchor!\n      n: 1,\n      size: project.baseResolution || '1024x1024',\n    }),\n  });\n\n  const data = await response.json();\n  const imageUrl = data.data[0].url;\n\n  // 4. Download and save\n  const imageBlob = await fetch(imageUrl).then(r => r.blob());\n\n  await prisma.generatedAsset.create({\n    data: {\n      projectId,\n      assetId,\n      image_blob: Buffer.from(await imageBlob.arrayBuffer()),\n      prompt_used: prompt,\n      status: 'generated',\n      generation_metadata: JSON.stringify({\n        model: 'flux.2-dev',\n        seed: data.data[0].seed,\n        cost: calculateCost(project.baseResolution),\n      }),\n    },\n  });\n\n  return Response.json({ success: true, assetId });\n}\n```\n\n#### 6\\. Style Anchor Integration (Flux.2 Consistency)\n\nThe biggest challenge in AI image generation is consistency. If you generate a hero and then a monster, they often look like they belong to different games. We solved this using **Style Anchors**.\n\nWhen generating assets, we pass the project's style anchor image and extracted keywords to the **Flux.2** model. This \"anchors\" the model to the specific aesthetic, palette, and perspective of the approved reference image.\n\n### 7\\. Explicit Decision: Individual vs. Batch Generation\n\nMid-implementation, I hit a philosophical crossroad. Do I just hit \"Generate All\" and let the AI build everything in the background?\n\n**I chose Individual Generation.**\n\nWhy? Because game development is iterative. You need to see if the AI understands the \"Farmer\" character before you generate \"Farmer - Walking Animation.\" By adding an explicit **Approval Workflow**, we prevent wasting API credits on misaligned assets.\n\n### 8\\. Asset Approval System (The User Pivot)\n\nUser feedback (well, my own dog-fooding) led to a more interactive flow. Every generation now lands in an \"Awaiting Approval\" queue\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1767567546781/e915437b-f039-43f3-8526-37479355f76c.png align=\"center\")\n\n.\n\n```typescript\n// components/generation/AssetApprovalCard.tsx\n// Features a large preview, metadata, and big Approve/Reject buttons at the top.\n// Approval converts the base64 preview into a persistent Blob stored in Dexie.\n```\n\n---\n\n## The Production Workflow: FilesPanel & AssetsPanel\n\nGeneration isn't just about calling an API; it's about managing a pipeline. We implemented two distinct panels:\n\n1. **FilesPanel**: For project source files (plans, style drafts, character registries).\n    \n2. **AssetsPanel**: A dedicated library for all *approved* generated assets.\n    \n\n### Features of the AssetsPanel:\n\n* **Grid Layout**: A sleek 2-column grid showing thumbnails of every approved sprite.\n    \n* **Detail View**: Full-screen preview with complete metadata (seed, model, prompt used).\n    \n* **Regeneration**: Found a bug? Edit the prompt and regenerate directly from the panel.\n    \n\n## The Aesthetic Shift: Premium Typography\n\nAs we moved into production, the default \"developer\" look (Inter everywhere) felt too clinical for a game dev tool.\n\nI updated the entire design system to a \"Premium Developer Blog\" aesthetic:\n\n* **Headings**: Serif (**Playfair Display**) for a sophisticated, editorial feel.\n    \n* **Body**: Clean Sans-serif (**Inter**) for maximum readability.\n    \n* **Accents**: Aurora gradients and glassmorphism elements to maintain the \"cosmic\" vibe.\n    \n\n---\n\n## Multi-Mode Planning UI\n\nOne last architectural decision: **Keep users in one page, switch modes** instead of navigating between separate pages.\n\n```markdown\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ [Plan] [Style] [Generation]  üìÑ Files [‚ñº] ‚îÇ ‚Üê Tabs\n‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n‚îÇ                ‚îÇ                           ‚îÇ\n‚îÇ  Chat (Left)   ‚îÇ   Right Panel (Mode)      ‚îÇ\n‚îÇ                ‚îÇ                           ‚îÇ\n‚îÇ  - User msgs   ‚îÇ   Plan Mode:              ‚îÇ\n‚îÇ  - AI msgs     ‚îÇ   ‚îî‚îÄ Markdown preview     ‚îÇ\n‚îÇ  - Tools       ‚îÇ                           ‚îÇ\n‚îÇ                ‚îÇ   Style Mode:             ‚îÇ\n‚îÇ  (Persists     ‚îÇ   ‚îî‚îÄ Image upload        ‚îÇ\n‚îÇ   across       ‚îÇ   ‚îî‚îÄ Keyword editor       ‚îÇ\n‚îÇ   modes)       ‚îÇ   ‚îî‚îÄ Color palette        ‚îÇ\n‚îÇ                ‚îÇ                           ‚îÇ\n‚îÇ                ‚îÇ   Generation Mode:        ‚îÇ\n‚îÇ                ‚îÇ   ‚îî‚îÄ Asset queue          ‚îÇ\n‚îÇ                ‚îÇ   ‚îî‚îÄ Progress tracking    ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n**Why?**\n\n* Consistent UX (don't lose chat context)\n    \n* Natural workflow (continue conversation across phases)\n    \n* No page transitions (faster, smoother)\n    \n* File menu accessible (see saved files anytime)\n    \n\n**Implementation:**\n\n```typescript\n// app/project/[id]/planning/page.tsx\nexport default function PlanningPage({ params }: { params: { id: string } }) {\n  const [mode, setMode] = useState<'plan' | 'style' | 'generation'>('plan');\n\n  return (\n    <div className=\"grid grid-cols-2 gap-4\">\n      {/* Left: Chat (always visible) */}\n      <ChatInterface projectId={params.id} />\n\n      {/* Right: Mode-specific panel */}\n      <div>\n        <Tabs value={mode} onValueChange={setMode}>\n          <TabsList>\n            <TabsTrigger value=\"plan\">Plan</TabsTrigger>\n            <TabsTrigger value=\"style\">Style</TabsTrigger>\n            <TabsTrigger value=\"generation\">Generation</TabsTrigger>\n          </TabsList>\n        </Tabs>\n\n        {mode === 'plan' && <PlanPreview />}\n        {mode === 'style' && <StyleAnchorEditor />}\n        {mode === 'generation' && <GenerationQueue />}\n      </div>\n    </div>\n  );\n}\n```\n\n## The Results\n\n**Results Update (Dec 28):**\n\n* **Tests**: 15 unit and integration tests (100% coverage on core generation logic).\n    \n* **Workflow**: 100% functional individual generation ‚Üí approval ‚Üí persistent storage flow.\n    \n* **UI**: Premium typography integration complete. FilesPanel and AssetsPanel active.\n    \n* **Performance**: Flux.2 generation averaging ~6-8s via OpenRouter.\n    \n\n> \\[!NOTE\\] While the generation logic was solid, we soon discovered critical security gaps in our API endpoints. We dive into the audit and hardening process in the next post.\n\n**Commits:**\n\n```bash\ncommit a12bc3d - feat(generation): implement individual asset generation workflow and approval system\ncommit f4e5d6c - feat(ui): refine typography to Playfair Display / Inter\ncommit f01953c - feat(generation): fix plan loading 404\ncommit bea7089 - feat(style-anchor): implement Flux.2 image generation via OpenRouter\ncommit 475030a - feat(ui): implement FilesPanel and AssetsPanel for asset management\ncommit a4846e7 - Complete P0 generation infrastructure\ncommit bb2833b - Add plan parser and multi-mode planning page\n```\n\n---\n\n## What I Learned\n\n**1\\. Tests prevent architecture surprises**\n\nAfter CopilotKit and IndexedDB failures, tests gave confidence each piece worked before building on it.\n\n**2\\. Prompt engineering is software engineering**\n\nTemplates, priority ordering, token limits‚Äîit's not just \"vibes,\" it's architecture.\n\n**3\\. Word order matters in image models**\n\nFlux.2 weighs first 5 words heaviest. `\"pixel art sprite of farmer\"` beats `\"a farmer sprite in pixel art style\"`.\n\n**4\\. Composite &gt; Granular by default**\n\nGame devs expect sprite sheets. LLMs can see full sheets better. Fewer API calls.\n\n**5\\. Style anchors are critical**\n\nWithout reference images, every asset looks different. With them, consistency jumps dramatically.\n\n**6\\. Multi-mode beats multi-page**\n\nKeeping users in one context with mode switching is smoother than full-page navigations.\n\n**7\\. Individual Approval &gt; Batch Fire-and-Forget**\n\nThe quality gate of a human clicking \"Approve\" is the difference between a project of 50 random images and a cohesive game asset library.\n\n---\n\n## Coming Next\n\nIn [Part 7: Hardening](07-hardening-battle-testing-the-api.md), we move beyond \"it works\" to \"it's safe\".\n\nWhat happens when an automated security bot audits your AI-generated code? We find unauthenticated endpoints, race conditions, and error leaks‚Äîand fix them all.\n\n**Spoiler:** AI is a great coder, but it's not a security auditor (yet).\n\n---\n\n**Commit References:**\n\n* `a4846e7` - Complete P0 generation infrastructure implementation\n    \n* `bb2833b` - Add plan parser and multi-mode planning page\n    \n* `f401d5a` - Add style phase AI tools and integration\n    \n* `0345fda` - Complete core AI integration\n    \n\n**Files Created:**\n\n* `/components/generation/AssetApprovalCard.tsx` - Per-asset UI\n    \n* `/components/ui/AssetsPanel.tsx` - Library management\n    \n* `/lib/prompt-templates.ts` - 6 asset-type templates\n    \n* `/lib/prompt-builder.ts` - Priority-ordered generation\n    \n* `/lib/plan-parser.ts` - Markdown ‚Üí ParsedAsset\\[\\]\n    \n* `/lib/image-utils.ts` - Blob/base64, color extraction\n    \n* `/app/api/generate/route.ts` - Generation endpoint\n    \n* `/__tests__/**/*.test.ts` - 12+ integration tests\n    \n\n**Total Lines Added:** ~3,450\n\n---\n\n**Previous:** [‚Üê Part 5: The Architecture](05-the-architecture-hybrid-persistence.md)**Next:** [Part 7: Hardening ‚Üí](07-hardening-battle-testing-the-api.md)",
  "brief": "Previously:\nSolved the hybrid persistence architecture. Dexie for client, Prisma for server, sync between them.\nNow: Time to build the generation infrastructure and make this production-ready.\nThe Test-First Pivot\nAfter two architectural crises (Copi...",
  "author": "695abff5e4c04d1036cd307d",
  "sB": false,
  "isRepublished": false,
  "readTime": 11,
  "draft": "695af03ff5b445b14eb4e94e",
  "tags": [
    "56744723958ef13879b9549b",
    "56cfe81bfa28f5fe7f74d215",
    "685cc368b61b171ea24ece4b",
    "639eeb95d1e499a9b88a2301",
    "5c2e005500d8d38a43560574",
    "57067a5e115103c3b097818b"
  ],
  "publication": "695ac03d428b39bd40085e89",
  "ogImage": "https://cdn.hashnode.com/res/hashnode/image/upload/v1767567581866/fa3f7d9d-0000-47c6-9325-d7cad3af7b3c.png",
  "metaTitle": "Testing AI Applications: Jest, Flux.2, and Prompt Templates | Part 6",
  "metaDescription": "Integration tests for AI routes, prompt engineering for Flux.2, and building a multi-mode planning UI. Making AI-generated code production-ready.",
  "series": "695ac45c21b769e7641e57a5",
  "isNewsletterActivated": true,
  "coAuthors": [],
  "dateUpdated": "2026-01-04T23:12:54.276Z",
  "hasCustomDate": false,
  "pollOptions": [],
  "badges": [],
  "questionReplies": [],
  "contributors": [],
  "uniqueReactions": [],
  "reactionToCountMapUnique": {
    "any": 1
  },
  "id": "695af139b10cf08042f6dded"
}