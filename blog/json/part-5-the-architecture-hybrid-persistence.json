{
  "reward": {
    "type": "xlm"
  },
  "sourcedFromGithub": false,
  "githubAsSourceMeta": null,
  "isAnonymous": false,
  "coverImage": "",
  "autoGeneratedCover": "",
  "hasPolls": false,
  "totalPollVotes": 0,
  "upvotes": 0,
  "downvotes": 0,
  "untaggedFrom": [],
  "upvotedBy": [],
  "downvotedBy": [],
  "responses": [],
  "followers": [],
  "answeredByTarget": false,
  "inviters": [],
  "duplicatePosts": [],
  "hasReward": false,
  "bookmarkedIn": [],
  "similarPostIds": [],
  "reactionsByCurrentUser": [],
  "toc": [],
  "_id": "695aef8d08fa9642a4c89254",
  "createdAt": "2026-01-04T22:54:05.996Z",
  "updatedAt": "2026-01-04T22:54:05.996Z",
  "views": 2,
  "isActive": true,
  "hasLatex": false,
  "popularity": 7967.9121,
  "discussionScore": 0,
  "enableToc": false,
  "type": "story",
  "partOfPublication": true,
  "responseCount": 0,
  "replyCount": 0,
  "isFeatured": false,
  "isEngaging": false,
  "isDelisted": false,
  "isNotified": false,
  "numCollapsed": 0,
  "reactions": [],
  "totalReactions": 0,
  "totalReactionsByCurrentUser": 0,
  "isPinnedToBlog": false,
  "disableComments": false,
  "commentsPaused": false,
  "syncAlgolia": false,
  "numUniqueUsersWhoReacted": 0,
  "slugOverridden": false,
  "tweetOptions": {
    "enabled": false
  },
  "title": "Part 5: The Architecture - Hybrid Persistence",
  "cuid": "cmk0bwfqj000602jx743z1177",
  "dateAdded": "2026-01-04T22:54:05.995Z",
  "isCoverAttributionHidden": false,
  "coverImageAttribution": "",
  "coverImagePhotographer": "",
  "stickCoverToBottom": false,
  "slug": "part-5-the-architecture-hybrid-persistence",
  "content": "<p><strong>Previously:</strong> Migrated from CopilotKit to Vercel AI SDK. Tools work! Planning phase complete.</p>\n<p><strong>Now:</strong> Building the generation infrastructure and hitting another architectural wall.</p>\n<h2 id=\"heading-the-problem-emerges\">The Problem Emerges</h2>\n<p>It's late afternoon on Dec 26. Tools are working. I'm feeling good. Time to build the <code>/api/generate</code> route for image generation.</p>\n<pre><code class=\"lang-typescript\"><span class=\"hljs-comment\">// app/api/generate/route.ts</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">POST</span>(<span class=\"hljs-params\">req: Request</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> { projectId, assetId } = <span class=\"hljs-keyword\">await</span> req.json();\n\n  <span class=\"hljs-comment\">//  Need:</span>\n  <span class=\"hljs-comment\">// 1. Project qualities (art_style, perspective, etc.)</span>\n  <span class=\"hljs-comment\">// 2. Style anchor image (reference for consistency)</span>\n  <span class=\"hljs-comment\">// 3. Asset specifications from plan</span>\n\n  <span class=\"hljs-keyword\">const</span> project = <span class=\"hljs-keyword\">await</span> db.projects.get(projectId);\n  <span class=\"hljs-keyword\">const</span> styleAnchor = <span class=\"hljs-keyword\">await</span> db.styleAnchors.get(project.style_anchor_id);\n\n  <span class=\"hljs-comment\">// Generate image with Flux.2...</span>\n}\n</code></pre>\n<p><strong>Run the server:</strong></p>\n<pre><code class=\"lang-markdown\">Error: db.projects is not defined\nTypeError: Cannot read property 'get' of undefined\n</code></pre>\n<p>Wait, what? I'm importing <code>db</code> from <code>/lib/db.ts</code> where I defined the Dexie database.</p>\n<p><strong>Try logging:</strong></p>\n<pre><code class=\"lang-typescript\"><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'db:'</span>, db);\n<span class=\"hljs-comment\">// Output: undefined</span>\n</code></pre>\n<h3 id=\"heading-the-realization\">The Realization</h3>\n<p><strong>IndexedDB only exists in browsers.</strong></p>\n<p>API routes run in Node.js (server-side). There is no <code>window</code>, no <code>indexedDB</code>, no Dexie.</p>\n<pre><code class=\"lang-markdown\">Client (Browser)     Server (Node.js)\n─────────────────    ─────────────────\n✅ IndexedDB          ❌ IndexedDB\n✅ Dexie              ❌ Dexie\n✅ window             ❌ window\n✅ localStorage       ❌ localStorage\n</code></pre>\n<p><strong>But I need to access project data from the server</strong> to pass it to Flux.2 for image generation!</p>\n<h2 id=\"heading-the-options\">The Options</h2>\n<h3 id=\"heading-option-1-send-everything-in-request-body\">Option 1: Send Everything in Request Body</h3>\n<pre><code class=\"lang-typescript\"><span class=\"hljs-comment\">// Client sends full project + style anchor in every request</span>\nfetch(<span class=\"hljs-string\">'/api/generate'</span>, {\n  body: <span class=\"hljs-built_in\">JSON</span>.stringify({\n    qualities: { art_style: <span class=\"hljs-string\">'...'</span>, ... },\n    styleAnchorImage: <span class=\"hljs-string\">'data:image/png;base64,...'</span> <span class=\"hljs-comment\">// 5MB+</span>\n    plan: <span class=\"hljs-string\">'...'</span>,\n  })\n});\n</code></pre>\n<p><strong>Problems:</strong></p>\n<ul>\n<li><p>Massive payloads (style anchor images are 2-5MB each)</p>\n</li>\n<li><p>Client has to fetch everything first (multiple IndexedDB queries)</p>\n</li>\n<li><p>Poor data integrity (client could send stale data)</p>\n</li>\n<li><p>Lots of boilerplate</p>\n</li>\n</ul>\n<p><strong>Verdict:</strong> ❌ Terrible DX, wasteful</p>\n<h3 id=\"heading-option-2-migrate-everything-to-server-db\">Option 2: Migrate Everything to Server DB</h3>\n<pre><code class=\"lang-typescript\"><span class=\"hljs-comment\">// lib/db.ts → lib/server-db.ts with Prisma</span>\n<span class=\"hljs-comment\">// All data in PostgreSQL or SQLite</span>\n<span class=\"hljs-comment\">// IndexedDB gone entirely</span>\n</code></pre>\n<p><strong>Problems:</strong></p>\n<ul>\n<li><p>Massive migration effort (rewrite all DB calls)</p>\n</li>\n<li><p>Lose Dexie's reactive <code>useLiveQuery</code> hooks</p>\n</li>\n<li><p>Need server for development (can't work offline)</p>\n</li>\n<li><p>Have to set up authentication earlier than planned</p>\n</li>\n</ul>\n<p><strong>Verdict:</strong> ❌ Too much work, loses client-side benefits</p>\n<h3 id=\"heading-option-3-hybrid-persistence\">Option 3: Hybrid Persistence</h3>\n<p><strong>What if both exist?</strong></p>\n<ul>\n<li><p><strong>Client (Dexie/IndexedDB):</strong> UI state, reactive queries, fast reads</p>\n</li>\n<li><p><strong>Server (Prisma/SQLite):</strong> Source of truth for generation, API routes</p>\n</li>\n<li><p><strong>Sync:</strong> 4-layered management (URL → LocalStorage → Dexie → Prisma) to ensure data is never lost.</p>\n</li>\n<li><p><strong>Verification</strong>: Atomic writes guarded by database unique constraints.</p>\n</li>\n</ul>\n<pre><code class=\"lang-markdown\">┌─────────────────┐         ┌──────────────────┐\n│  Client (UI)    │         │  Server (API)    │\n│                 │         │                  │\n│  Dexie (Cache)  │◄────────┤  Prisma (Truth)  │\n│  IndexedDB      │  Fetch  │  SQLite          │\n│                 │         │                  │\n│  useLiveQuery   │         │  API Routes      │\n│  Fast UI Updates│         │  Generation      │\n└─────────────────┘         └──────────────────┘\n<span class=\"hljs-code\">         │                           ▲\n         └───── POST /api/... ───────┘\n               (Dual-write on save)</span>\n</code></pre>\n<p><strong>Benefits:</strong></p>\n<ul>\n<li><p>Keep Dexie for UI (reactive, fast, offline-capable)</p>\n</li>\n<li><p>Add Prisma for server (reliable, queryable from API routes)</p>\n</li>\n<li><p>Incremental migration (move tables one at a time)</p>\n</li>\n</ul>\n<p><strong>Costs:</strong></p>\n<ul>\n<li><p>Sync complexity (data can drift if not careful)</p>\n</li>\n<li><p>Redundant schemas (maintain both Dexie and Prisma)</p>\n</li>\n<li><p>More code to manage</p>\n</li>\n</ul>\n<p><strong>Verdict:</strong> ✅ Best balance of velocity and robustness (Formalized in ADR 012)</p>\n<h2 id=\"heading-the-councils-solution-4-layer-persistence\">The Council's Solution: 4-Layer Persistence</h2>\n<p>I wasn't sure if this was the right path, so I summoned my <strong>Council of AIs</strong> (Claude, Chat-PT, and Perplexity) to review the problem. I gave the same prompt to each of t hem, and then had Grandaddy Pus synthesize the results into the best method for our app.</p>\n<p>Their consensus? A tiered approach where each layer serves a specific purpose:</p>\n<ol>\n<li><p><strong>URL Params</strong>: For instant, shareable UI state (Phase, Model).</p>\n</li>\n<li><p><strong>LocalStorage</strong>: For high-frequency, non-critical settings.</p>\n</li>\n<li><p><strong>Dexie</strong>: For the heavy lifting on the client (Reactivity, Offline).</p>\n</li>\n<li><p><strong>Prisma</strong>: The ultimate source of truth for the generation engine.</p>\n</li>\n</ol>\n<h3 id=\"heading-implementation-hybrid-persistence\">Implementation: Hybrid Persistence</h3>\n<h3 id=\"heading-step-1-install-prisma\">Step 1: Install Prisma</h3>\n<pre><code class=\"lang-bash\">bun add prisma @prisma/client\nbun add -D prisma\n\nbunx prisma init --datasource-provider sqlite\n</code></pre>\n<p><strong>Why SQLite?</strong></p>\n<ul>\n<li><p>File-based (no server to run during development)</p>\n</li>\n<li><p>Fast for local dev</p>\n</li>\n<li><p>Can migrate to PostgreSQL later if needed</p>\n</li>\n</ul>\n<h3 id=\"heading-step-2-define-schema\">Step 2: Define Schema</h3>\n<pre><code class=\"lang-markdown\">// prisma/schema.prisma\ngenerator client {\n  provider = \"prisma-client-js\"\n}\n\ndatasource db {\n  provider = \"sqlite\"\n  url      = \"file:./dev.db\"\n}\n\nmodel Project {\n  id              String   @id @default(uuid())\n  name            String\n  description     String?\n  phase           String   @default(\"planning\")\n\n  // Quality parameters\n  artStyle        String?  @map(\"art<span class=\"hljs-emphasis\">_style\")\n  baseResolution  String?  @map(\"base_</span>resolution\")\n  perspective     String?\n  gameGenre       String?  @map(\"game<span class=\"hljs-emphasis\">_genre\")\n  theme           String?\n  mood            String?\n  colorPalette    String?  @map(\"color_</span>palette\")\n\n  createdAt       DateTime @default(now()) @map(\"created<span class=\"hljs-emphasis\">_at\")\n  updatedAt       DateTime @updatedAt @map(\"updated_</span>at\")\n\n  memoryFiles     MemoryFile[]\n  styleAnchors    StyleAnchor[]\n\n  @@map(\"projects\")\n}\n\nmodel MemoryFile {\n  id         String   @id @default(uuid())\n  projectId  String   @map(\"project<span class=\"hljs-emphasis\">_id\")\n  fileName   String   @map(\"file_</span>name\")\n  content    String   // JSON or markdown\n  version    Int      @default(1)\n  createdAt  DateTime @default(now()) @map(\"created<span class=\"hljs-emphasis\">_at\")\n\n  project    Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)\n\n  @@unique([projectId, type])\n  @@map(\"memory_</span>files\")\n}\n\nmodel StyleAnchor {\n  id                    String   @id @default(uuid())\n  projectId             String   @map(\"project<span class=\"hljs-emphasis\">_id\")\n  referenceImageBlob    Bytes    @map(\"reference_</span>image<span class=\"hljs-emphasis\">_blob\")\n  referenceImageBase64  String?  @map(\"reference_</span>image<span class=\"hljs-emphasis\">_base64\") // Cached\n  styleKeywords         String   @map(\"style_</span>keywords\")\n  lightingKeywords      String   @map(\"lighting<span class=\"hljs-emphasis\">_keywords\")\n  colorPalette          String   @map(\"color_</span>palette\") // JSON array\n  createdAt             DateTime @default(now()) @map(\"created<span class=\"hljs-emphasis\">_at\")\n\n  project               Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)\n\n  @@map(\"style_</span>anchors\")\n}\n\nmodel GeneratedAsset {\n  id                  String   @id @default(uuid())\n  projectId           String   @map(\"project<span class=\"hljs-emphasis\">_id\")\n  assetId             String   @map(\"asset_</span>id\")\n  variantId           String?  @map(\"variant<span class=\"hljs-emphasis\">_id\")\n  imageBlob           Bytes    @map(\"image_</span>blob\")\n  imageBase64         String?  @map(\"image<span class=\"hljs-emphasis\">_base64\")\n  promptUsed          String   @map(\"prompt_</span>used\")\n  status              String   @default(\"generated\")\n  generationMetadata  String   @map(\"generation<span class=\"hljs-emphasis\">_metadata\") // JSON\n  createdAt           DateTime @default(now()) @map(\"created_</span>at\")\n  updatedAt           DateTime @updatedAt @map(\"updated<span class=\"hljs-emphasis\">_at\")\n\n  project             Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)\n\n  @@map(\"generated_</span>assets\")\n}\n</code></pre>\n<p><strong>Run migration:</strong></p>\n<pre><code class=\"lang-bash\">bunx prisma migrate dev --name init\nbunx prisma generate\n</code></pre>\n<h3 id=\"heading-step-3-prisma-client-singleton\">Step 3: Prisma Client Singleton</h3>\n<pre><code class=\"lang-typescript\"><span class=\"hljs-comment\">// lib/prisma.ts</span>\n<span class=\"hljs-keyword\">import</span> { PrismaClient } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@prisma/client'</span>;\n\n<span class=\"hljs-keyword\">const</span> globalForPrisma = globalThis <span class=\"hljs-keyword\">as</span> unknown <span class=\"hljs-keyword\">as</span> {\n  prisma: PrismaClient | <span class=\"hljs-literal\">undefined</span>;\n};\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> prisma = globalForPrisma.prisma ?? <span class=\"hljs-keyword\">new</span> PrismaClient();\n\n<span class=\"hljs-keyword\">if</span> (process.env.NODE_ENV !== <span class=\"hljs-string\">'production'</span>) {\n  globalForPrisma.prisma = prisma;\n}\n</code></pre>\n<p><strong>Why singleton?</strong> Next.js hot-reload creates new Prisma instances on every change. Singleton prevents database connection exhaustion.</p>\n<h3 id=\"heading-step-4-separate-client-and-server-dbs\">Step 4: Separate Client and Server DBs</h3>\n<pre><code class=\"lang-bash\"><span class=\"hljs-comment\"># Rename existing db.ts</span>\nmv lib/db.ts lib/client-db.ts\n\n<span class=\"hljs-comment\"># Update imports in all client components</span>\n<span class=\"hljs-comment\"># sed -i 's/@\\/lib\\/db/@\\/lib\\/client-db/g' **/*.tsx</span>\n</code></pre>\n<p><strong>Result:</strong></p>\n<ul>\n<li><p><code>lib/client-db.ts</code> - Dexie (browser-only)</p>\n</li>\n<li><p><code>lib/prisma.ts</code> - Prisma (server-only)</p>\n</li>\n</ul>\n<h3 id=\"heading-step-5-dual-write-on-save\">Step 5: Dual-Write on Save</h3>\n<p>When user saves a style anchor:</p>\n<pre><code class=\"lang-typescript\"><span class=\"hljs-comment\">// components/style/StyleAnchorEditor.tsx</span>\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">handleSave</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-comment\">// 1. Write to server (source of truth)</span>\n  <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> fetch(<span class=\"hljs-string\">'/api/style-anchors'</span>, {\n    method: <span class=\"hljs-string\">'POST'</span>,\n    body: <span class=\"hljs-built_in\">JSON</span>.stringify({\n      projectId,\n      referenceImageBlob: <span class=\"hljs-keyword\">await</span> blobToBase64(imageBlob),\n      styleKeywords,\n      lightingKeywords,\n      colorPalette,\n    }),\n  });\n\n  <span class=\"hljs-keyword\">const</span> savedAnchor = <span class=\"hljs-keyword\">await</span> response.json();\n\n  <span class=\"hljs-comment\">// 2. Update client cache (for UI)</span>\n  <span class=\"hljs-keyword\">await</span> clientDb.styleAnchors.put({\n    id: savedAnchor.id,\n    project_id: projectId,\n    reference_image_blob: imageBlob,\n    style_keywords: styleKeywords,\n    <span class=\"hljs-comment\">// ...</span>\n  });\n\n  toast.success(<span class=\"hljs-string\">'Style anchor saved!'</span>);\n}\n</code></pre>\n<p><strong>Flow:</strong></p>\n<ol>\n<li><p>POST to server → Prisma saves to SQLite</p>\n</li>\n<li><p>On success → Update Dexie cache</p>\n</li>\n<li><p>UI reads from Dexie (instant, reactive)</p>\n</li>\n<li><p>API routes read from Prisma (reliable, always fresh)</p>\n</li>\n</ol>\n<h2 id=\"heading-the-indexeddb-polyfill-hack\">The IndexedDB Polyfill Hack</h2>\n<p>One problem remained: <strong>Unit tests</strong>.</p>\n<pre><code class=\"lang-typescript\"><span class=\"hljs-comment\">// __tests__/api/generate/route.test.ts</span>\n<span class=\"hljs-keyword\">import</span> { POST } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@/app/api/generate/route'</span>;\n\ntest(<span class=\"hljs-string\">'generates asset successfully'</span>, <span class=\"hljs-keyword\">async</span> () =&gt; {\n  <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> POST(mockRequest);\n  <span class=\"hljs-comment\">// ...</span>\n});\n</code></pre>\n<p><strong>Error:</strong></p>\n<pre><code class=\"lang-markdown\">ReferenceError: indexedDB is not defined\n<span class=\"hljs-code\">    at lib/client-db.ts:8:11</span>\n</code></pre>\n<p>Even though API routes don't use Dexie, <strong>importing them</strong> causes <code>client-db.ts</code> to load, which tries to access <code>window.indexedDB</code>.</p>\n<h3 id=\"heading-the-solution-conditional-polyfill\">The Solution: Conditional Polyfill</h3>\n<pre><code class=\"lang-typescript\"><span class=\"hljs-comment\">// lib/client-db.ts</span>\n<span class=\"hljs-keyword\">import</span> Dexie <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'dexie'</span>;\n\n<span class=\"hljs-comment\">// Polyfill IndexedDB for Node.js (tests, API routes)</span>\n<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">window</span> === <span class=\"hljs-string\">'undefined'</span>) {\n  <span class=\"hljs-keyword\">const</span> { indexedDB } = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">'fake-indexeddb'</span>);\n  (globalThis <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">any</span>).indexedDB = indexedDB;\n}\n\n<span class=\"hljs-keyword\">class</span> AssetHatchDB <span class=\"hljs-keyword\">extends</span> Dexie {\n  <span class=\"hljs-comment\">// ... schema ...</span>\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> clientDb = <span class=\"hljs-keyword\">new</span> AssetHatchDB();\n</code></pre>\n<p><strong>Install:</strong></p>\n<pre><code class=\"lang-bash\">bun add -D fake-indexeddb\n</code></pre>\n<p><strong>Result:</strong></p>\n<ul>\n<li><p>✅ Browser: Uses real IndexedDB</p>\n</li>\n<li><p>✅ Node.js (tests, API routes): Uses fake-indexeddb</p>\n</li>\n<li><p>✅ No crashes</p>\n</li>\n</ul>\n<p><strong>Trade-off:</strong> This is a hack. But it works and unblocks development.</p>\n<h2 id=\"heading-adr-007httpsgithubcomzenchantliveasset-hatchblobmainsrcmemoryadr007-hybrid-persistence-modelmd-hybrid-persistence-model\"><a target=\"_blank\" href=\"https://github.com/zenchantlive/Asset-Hatch/blob/main/src/memory/adr/007-hybrid-persistence-model.md\">ADR-007</a>: Hybrid Persistence Model</h2>\n<p><strong>Status:</strong> Accepted <strong>Date:</strong> 2025-12-26</p>\n<p><strong>Context:</strong> API routes need server-side access to project data for image generation. IndexedDB doesn't exist in Node.js.</p>\n<p><strong>Decision:</strong> Implement hybrid persistence:</p>\n<ul>\n<li><p><strong>Client:</strong> Dexie/IndexedDB (cache, reactive UI)</p>\n</li>\n<li><p><strong>Server:</strong> Prisma/SQLite (source of truth, API access)</p>\n</li>\n<li><p><strong>Sync:</strong> Dual-write on mutations</p>\n</li>\n</ul>\n<p><strong>Rationale:</strong></p>\n<ul>\n<li><p>Keeps Dexie's excellent DX for UI</p>\n</li>\n<li><p>Adds reliable server-side data access</p>\n</li>\n<li><p>Incremental migration path</p>\n</li>\n<li><p>Works offline (client-side cache)</p>\n</li>\n</ul>\n<p><strong>Consequences:</strong></p>\n<ul>\n<li><p><strong>Positive:</strong> Best of both worlds, incremental adoption</p>\n</li>\n<li><p><strong>Negative:</strong> Sync complexity, redundant schemas</p>\n</li>\n<li><p><strong>Mitigation:</strong> Server write is source of truth; client is cache</p>\n</li>\n</ul>\n<hr />\n<h2 id=\"heading-what-i-learned\">What I Learned</h2>\n<p><strong>1. Server vs Client is Real</strong></p>\n<p>IndexedDB, localStorage, window—all browser-only. Can't assume anything works in API routes.</p>\n<p><strong>2. Hybrid isn't a cop-out</strong></p>\n<p>It's a legitimate pattern when you have conflicting requirements (reactive UI + server access).</p>\n<p><strong>3. Polyfills save time</strong></p>\n<p><code>fake-indexeddb</code> let me keep tests running without refactoring every import.</p>\n<p><strong>4. Source of truth matters</strong></p>\n<p>When data exists in two places, one must be canonical. Server writes are truth; client is cache.</p>\n<p><strong>5. Migration doesn't have to be big-bang</strong></p>\n<p>Moved <code>StyleAnchor</code> to Prisma first. Will move <code>Project</code> and <code>MemoryFile</code> later as needed.</p>\n<hr />\n<h2 id=\"heading-coming-next\">Coming Next</h2>\n<p>In <a target=\"_blank\" href=\"06-productionization-tests-infrastructure.md\">Part 6: Productionization</a>, we make it production-ready:</p>\n<ul>\n<li><p>Integration tests for all API routes</p>\n</li>\n<li><p>Generation infrastructure with Flux.2</p>\n</li>\n<li><p>Prompt engineering templates</p>\n</li>\n<li><p>Multi-mode UI design</p>\n</li>\n</ul>\n<p><strong>Preview:</strong> Jest + Next.js 16 + Prisma + fake-indexeddb = configuration hell. But when it finally works, we have 100% test coverage on API routes.</p>\n<hr />\n<p><strong>Commit References:</strong></p>\n<ul>\n<li><p><code>0308291</code>, <code>b88f335</code> - Refactor tests and persistence layer</p>\n</li>\n<li><p>ADR-007, ADR-012 - Hybrid persistence and state management models</p>\n</li>\n</ul>\n<p><strong>Files Created:</strong></p>\n<ul>\n<li><p><code>/lib/prisma.ts</code> - Prisma client singleton</p>\n</li>\n<li><p><code>/prisma/schema.prisma</code> - Database schema</p>\n</li>\n<li><p><code>/lib/client-db.ts</code> - Renamed from db.ts</p>\n</li>\n<li><p><code>/app/api/style-anchors/route.ts</code> - Style anchor persistence API</p>\n</li>\n</ul>\n<hr />\n<p><strong>Previous:</strong> <a target=\"_blank\" href=\"04-the-pivot-vercel-ai-sdk.md\">← Part 4: The Pivot</a><strong>Next:</strong> <a target=\"_blank\" href=\"06-productionization-tests-infrastructure.md\">Part 6: Productionization →</a></p>\n",
  "contentMarkdown": "**Previously:** Migrated from CopilotKit to Vercel AI SDK. Tools work! Planning phase complete.\n\n**Now:** Building the generation infrastructure and hitting another architectural wall.\n\n## The Problem Emerges\n\nIt's late afternoon on Dec 26. Tools are working. I'm feeling good. Time to build the `/api/generate` route for image generation.\n\n```typescript\n// app/api/generate/route.ts\nexport async function POST(req: Request) {\n  const { projectId, assetId } = await req.json();\n\n  //  Need:\n  // 1. Project qualities (art_style, perspective, etc.)\n  // 2. Style anchor image (reference for consistency)\n  // 3. Asset specifications from plan\n\n  const project = await db.projects.get(projectId);\n  const styleAnchor = await db.styleAnchors.get(project.style_anchor_id);\n\n  // Generate image with Flux.2...\n}\n```\n\n**Run the server:**\n\n```markdown\nError: db.projects is not defined\nTypeError: Cannot read property 'get' of undefined\n```\n\nWait, what? I'm importing `db` from `/lib/db.ts` where I defined the Dexie database.\n\n**Try logging:**\n\n```typescript\nconsole.log('db:', db);\n// Output: undefined\n```\n\n### The Realization\n\n**IndexedDB only exists in browsers.**\n\nAPI routes run in Node.js (server-side). There is no `window`, no `indexedDB`, no Dexie.\n\n```markdown\nClient (Browser)     Server (Node.js)\n─────────────────    ─────────────────\n✅ IndexedDB          ❌ IndexedDB\n✅ Dexie              ❌ Dexie\n✅ window             ❌ window\n✅ localStorage       ❌ localStorage\n```\n\n**But I need to access project data from the server** to pass it to Flux.2 for image generation!\n\n## The Options\n\n### Option 1: Send Everything in Request Body\n\n```typescript\n// Client sends full project + style anchor in every request\nfetch('/api/generate', {\n  body: JSON.stringify({\n    qualities: { art_style: '...', ... },\n    styleAnchorImage: 'data:image/png;base64,...' // 5MB+\n    plan: '...',\n  })\n});\n```\n\n**Problems:**\n\n* Massive payloads (style anchor images are 2-5MB each)\n    \n* Client has to fetch everything first (multiple IndexedDB queries)\n    \n* Poor data integrity (client could send stale data)\n    \n* Lots of boilerplate\n    \n\n**Verdict:** ❌ Terrible DX, wasteful\n\n### Option 2: Migrate Everything to Server DB\n\n```typescript\n// lib/db.ts → lib/server-db.ts with Prisma\n// All data in PostgreSQL or SQLite\n// IndexedDB gone entirely\n```\n\n**Problems:**\n\n* Massive migration effort (rewrite all DB calls)\n    \n* Lose Dexie's reactive `useLiveQuery` hooks\n    \n* Need server for development (can't work offline)\n    \n* Have to set up authentication earlier than planned\n    \n\n**Verdict:** ❌ Too much work, loses client-side benefits\n\n### Option 3: Hybrid Persistence\n\n**What if both exist?**\n\n* **Client (Dexie/IndexedDB):** UI state, reactive queries, fast reads\n    \n* **Server (Prisma/SQLite):** Source of truth for generation, API routes\n    \n* **Sync:** 4-layered management (URL → LocalStorage → Dexie → Prisma) to ensure data is never lost.\n    \n* **Verification**: Atomic writes guarded by database unique constraints.\n    \n\n```markdown\n┌─────────────────┐         ┌──────────────────┐\n│  Client (UI)    │         │  Server (API)    │\n│                 │         │                  │\n│  Dexie (Cache)  │◄────────┤  Prisma (Truth)  │\n│  IndexedDB      │  Fetch  │  SQLite          │\n│                 │         │                  │\n│  useLiveQuery   │         │  API Routes      │\n│  Fast UI Updates│         │  Generation      │\n└─────────────────┘         └──────────────────┘\n         │                           ▲\n         └───── POST /api/... ───────┘\n               (Dual-write on save)\n```\n\n**Benefits:**\n\n* Keep Dexie for UI (reactive, fast, offline-capable)\n    \n* Add Prisma for server (reliable, queryable from API routes)\n    \n* Incremental migration (move tables one at a time)\n    \n\n**Costs:**\n\n* Sync complexity (data can drift if not careful)\n    \n* Redundant schemas (maintain both Dexie and Prisma)\n    \n* More code to manage\n    \n\n**Verdict:** ✅ Best balance of velocity and robustness (Formalized in ADR 012)\n\n## The Council's Solution: 4-Layer Persistence\n\nI wasn't sure if this was the right path, so I summoned my **Council of AIs** (Claude, Chat-PT, and Perplexity) to review the problem. I gave the same prompt to each of t hem, and then had Grandaddy Pus synthesize the results into the best method for our app.\n\nTheir consensus? A tiered approach where each layer serves a specific purpose:\n\n1. **URL Params**: For instant, shareable UI state (Phase, Model).\n    \n2. **LocalStorage**: For high-frequency, non-critical settings.\n    \n3. **Dexie**: For the heavy lifting on the client (Reactivity, Offline).\n    \n4. **Prisma**: The ultimate source of truth for the generation engine.\n    \n\n### Implementation: Hybrid Persistence\n\n### Step 1: Install Prisma\n\n```bash\nbun add prisma @prisma/client\nbun add -D prisma\n\nbunx prisma init --datasource-provider sqlite\n```\n\n**Why SQLite?**\n\n* File-based (no server to run during development)\n    \n* Fast for local dev\n    \n* Can migrate to PostgreSQL later if needed\n    \n\n### Step 2: Define Schema\n\n```markdown\n// prisma/schema.prisma\ngenerator client {\n  provider = \"prisma-client-js\"\n}\n\ndatasource db {\n  provider = \"sqlite\"\n  url      = \"file:./dev.db\"\n}\n\nmodel Project {\n  id              String   @id @default(uuid())\n  name            String\n  description     String?\n  phase           String   @default(\"planning\")\n\n  // Quality parameters\n  artStyle        String?  @map(\"art_style\")\n  baseResolution  String?  @map(\"base_resolution\")\n  perspective     String?\n  gameGenre       String?  @map(\"game_genre\")\n  theme           String?\n  mood            String?\n  colorPalette    String?  @map(\"color_palette\")\n\n  createdAt       DateTime @default(now()) @map(\"created_at\")\n  updatedAt       DateTime @updatedAt @map(\"updated_at\")\n\n  memoryFiles     MemoryFile[]\n  styleAnchors    StyleAnchor[]\n\n  @@map(\"projects\")\n}\n\nmodel MemoryFile {\n  id         String   @id @default(uuid())\n  projectId  String   @map(\"project_id\")\n  fileName   String   @map(\"file_name\")\n  content    String   // JSON or markdown\n  version    Int      @default(1)\n  createdAt  DateTime @default(now()) @map(\"created_at\")\n\n  project    Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)\n\n  @@unique([projectId, type])\n  @@map(\"memory_files\")\n}\n\nmodel StyleAnchor {\n  id                    String   @id @default(uuid())\n  projectId             String   @map(\"project_id\")\n  referenceImageBlob    Bytes    @map(\"reference_image_blob\")\n  referenceImageBase64  String?  @map(\"reference_image_base64\") // Cached\n  styleKeywords         String   @map(\"style_keywords\")\n  lightingKeywords      String   @map(\"lighting_keywords\")\n  colorPalette          String   @map(\"color_palette\") // JSON array\n  createdAt             DateTime @default(now()) @map(\"created_at\")\n\n  project               Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)\n\n  @@map(\"style_anchors\")\n}\n\nmodel GeneratedAsset {\n  id                  String   @id @default(uuid())\n  projectId           String   @map(\"project_id\")\n  assetId             String   @map(\"asset_id\")\n  variantId           String?  @map(\"variant_id\")\n  imageBlob           Bytes    @map(\"image_blob\")\n  imageBase64         String?  @map(\"image_base64\")\n  promptUsed          String   @map(\"prompt_used\")\n  status              String   @default(\"generated\")\n  generationMetadata  String   @map(\"generation_metadata\") // JSON\n  createdAt           DateTime @default(now()) @map(\"created_at\")\n  updatedAt           DateTime @updatedAt @map(\"updated_at\")\n\n  project             Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)\n\n  @@map(\"generated_assets\")\n}\n```\n\n**Run migration:**\n\n```bash\nbunx prisma migrate dev --name init\nbunx prisma generate\n```\n\n### Step 3: Prisma Client Singleton\n\n```typescript\n// lib/prisma.ts\nimport { PrismaClient } from '@prisma/client';\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined;\n};\n\nexport const prisma = globalForPrisma.prisma ?? new PrismaClient();\n\nif (process.env.NODE_ENV !== 'production') {\n  globalForPrisma.prisma = prisma;\n}\n```\n\n**Why singleton?** Next.js hot-reload creates new Prisma instances on every change. Singleton prevents database connection exhaustion.\n\n### Step 4: Separate Client and Server DBs\n\n```bash\n# Rename existing db.ts\nmv lib/db.ts lib/client-db.ts\n\n# Update imports in all client components\n# sed -i 's/@\\/lib\\/db/@\\/lib\\/client-db/g' **/*.tsx\n```\n\n**Result:**\n\n* `lib/client-db.ts` - Dexie (browser-only)\n    \n* `lib/prisma.ts` - Prisma (server-only)\n    \n\n### Step 5: Dual-Write on Save\n\nWhen user saves a style anchor:\n\n```typescript\n// components/style/StyleAnchorEditor.tsx\nasync function handleSave() {\n  // 1. Write to server (source of truth)\n  const response = await fetch('/api/style-anchors', {\n    method: 'POST',\n    body: JSON.stringify({\n      projectId,\n      referenceImageBlob: await blobToBase64(imageBlob),\n      styleKeywords,\n      lightingKeywords,\n      colorPalette,\n    }),\n  });\n\n  const savedAnchor = await response.json();\n\n  // 2. Update client cache (for UI)\n  await clientDb.styleAnchors.put({\n    id: savedAnchor.id,\n    project_id: projectId,\n    reference_image_blob: imageBlob,\n    style_keywords: styleKeywords,\n    // ...\n  });\n\n  toast.success('Style anchor saved!');\n}\n```\n\n**Flow:**\n\n1. POST to server → Prisma saves to SQLite\n    \n2. On success → Update Dexie cache\n    \n3. UI reads from Dexie (instant, reactive)\n    \n4. API routes read from Prisma (reliable, always fresh)\n    \n\n## The IndexedDB Polyfill Hack\n\nOne problem remained: **Unit tests**.\n\n```typescript\n// __tests__/api/generate/route.test.ts\nimport { POST } from '@/app/api/generate/route';\n\ntest('generates asset successfully', async () => {\n  const response = await POST(mockRequest);\n  // ...\n});\n```\n\n**Error:**\n\n```markdown\nReferenceError: indexedDB is not defined\n    at lib/client-db.ts:8:11\n```\n\nEven though API routes don't use Dexie, **importing them** causes `client-db.ts` to load, which tries to access `window.indexedDB`.\n\n### The Solution: Conditional Polyfill\n\n```typescript\n// lib/client-db.ts\nimport Dexie from 'dexie';\n\n// Polyfill IndexedDB for Node.js (tests, API routes)\nif (typeof window === 'undefined') {\n  const { indexedDB } = await import('fake-indexeddb');\n  (globalThis as any).indexedDB = indexedDB;\n}\n\nclass AssetHatchDB extends Dexie {\n  // ... schema ...\n}\n\nexport const clientDb = new AssetHatchDB();\n```\n\n**Install:**\n\n```bash\nbun add -D fake-indexeddb\n```\n\n**Result:**\n\n* ✅ Browser: Uses real IndexedDB\n    \n* ✅ Node.js (tests, API routes): Uses fake-indexeddb\n    \n* ✅ No crashes\n    \n\n**Trade-off:** This is a hack. But it works and unblocks development.\n\n## [ADR-007](https://github.com/zenchantlive/Asset-Hatch/blob/main/src/memory/adr/007-hybrid-persistence-model.md): Hybrid Persistence Model\n\n**Status:** Accepted **Date:** 2025-12-26\n\n**Context:** API routes need server-side access to project data for image generation. IndexedDB doesn't exist in Node.js.\n\n**Decision:** Implement hybrid persistence:\n\n* **Client:** Dexie/IndexedDB (cache, reactive UI)\n    \n* **Server:** Prisma/SQLite (source of truth, API access)\n    \n* **Sync:** Dual-write on mutations\n    \n\n**Rationale:**\n\n* Keeps Dexie's excellent DX for UI\n    \n* Adds reliable server-side data access\n    \n* Incremental migration path\n    \n* Works offline (client-side cache)\n    \n\n**Consequences:**\n\n* **Positive:** Best of both worlds, incremental adoption\n    \n* **Negative:** Sync complexity, redundant schemas\n    \n* **Mitigation:** Server write is source of truth; client is cache\n    \n\n---\n\n## What I Learned\n\n**1\\. Server vs Client is Real**\n\nIndexedDB, localStorage, window—all browser-only. Can't assume anything works in API routes.\n\n**2\\. Hybrid isn't a cop-out**\n\nIt's a legitimate pattern when you have conflicting requirements (reactive UI + server access).\n\n**3\\. Polyfills save time**\n\n`fake-indexeddb` let me keep tests running without refactoring every import.\n\n**4\\. Source of truth matters**\n\nWhen data exists in two places, one must be canonical. Server writes are truth; client is cache.\n\n**5\\. Migration doesn't have to be big-bang**\n\nMoved `StyleAnchor` to Prisma first. Will move `Project` and `MemoryFile` later as needed.\n\n---\n\n## Coming Next\n\nIn [Part 6: Productionization](06-productionization-tests-infrastructure.md), we make it production-ready:\n\n* Integration tests for all API routes\n    \n* Generation infrastructure with Flux.2\n    \n* Prompt engineering templates\n    \n* Multi-mode UI design\n    \n\n**Preview:** Jest + Next.js 16 + Prisma + fake-indexeddb = configuration hell. But when it finally works, we have 100% test coverage on API routes.\n\n---\n\n**Commit References:**\n\n* `0308291`, `b88f335` - Refactor tests and persistence layer\n    \n* ADR-007, ADR-012 - Hybrid persistence and state management models\n    \n\n**Files Created:**\n\n* `/lib/prisma.ts` - Prisma client singleton\n    \n* `/prisma/schema.prisma` - Database schema\n    \n* `/lib/client-db.ts` - Renamed from db.ts\n    \n* `/app/api/style-anchors/route.ts` - Style anchor persistence API\n    \n\n---\n\n**Previous:** [← Part 4: The Pivot](04-the-pivot-vercel-ai-sdk.md)**Next:** [Part 6: Productionization →](06-productionization-tests-infrastructure.md)",
  "brief": "Previously: Migrated from CopilotKit to Vercel AI SDK. Tools work! Planning phase complete.\nNow: Building the generation infrastructure and hitting another architectural wall.\nThe Problem Emerges\nIt's late afternoon on Dec 26. Tools are working. I'm ...",
  "author": "695abff5e4c04d1036cd307d",
  "sB": false,
  "isRepublished": false,
  "readTime": 8,
  "draft": "695ae3a618376cdba44555b4",
  "tags": [
    "695aef8d2ccfd97102b2ffb4",
    "56744723958ef13879b9529a",
    "5a748cf3f7ef75131419eb9e",
    "5c4c8cbe86ae9b1b6b0e9999",
    "56d9e25a4aa5f35f09dd6c98",
    "584879f0c0aaf085e2012086"
  ],
  "publication": "695ac03d428b39bd40085e89",
  "metaTitle": "Dexie + Prisma: Building a Hybrid Persistence Layer | Part 5",
  "metaDescription": "IndexedDB doesn't exist in Node.js. Here's how I solved the client-server data problem with a dual-database architecture using Dexie and Prisma.",
  "series": "695ac45c21b769e7641e57a5",
  "isNewsletterActivated": true,
  "coAuthors": [],
  "pollOptions": [],
  "badges": [],
  "questionReplies": [],
  "contributors": [],
  "uniqueReactions": [],
  "reactionToCountMapUnique": {
    "any": 1
  },
  "id": "695aef8d08fa9642a4c89254"
}