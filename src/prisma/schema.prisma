// -----------------------------------------------------------------------------
// Prisma schema for Asset Hatch
// Includes Auth.js v5 models (User, Account, Session, VerificationToken)
// and application models (Project, MemoryFile, StyleAnchor, etc.)
// -----------------------------------------------------------------------------

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  // No url needed - connection handled by Neon adapter in lib/prisma.ts
}

// =============================================================================
// AUTH.JS MODELS
// These models are required for Auth.js v5 with the Prisma adapter
// =============================================================================

// User model - stores authenticated users from OAuth or credentials
model User {
  id               String    @id @default(cuid())
  name             String?
  email            String    @unique
  emailVerified    DateTime?
  image            String?
  hashedPassword   String?   // For credentials provider (email/password auth)
  openRouterApiKey String?   // User's own OpenRouter API key for BYOK
  accounts         Account[]
  sessions         Session[]
  projects         Project[]
  games            Game[]    // Hatch Studios games relation
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
}

// Account model - links OAuth providers to users (GitHub, Google, etc.)
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

// Session model - stores active user sessions (for database strategy)
model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// VerificationToken model - for email verification and magic links
model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// =============================================================================
// APPLICATION MODELS
// Core business logic models for the asset generation workflow
// =============================================================================

// Project model - main entity representing a game asset project
model Project {
  id                  String              @id @default(uuid())
  userId              String?             // Nullable for existing projects without auth
  user                User?               @relation(fields: [userId], references: [id])
  name                String
  phase               String              @default("planning")
  mode                String              @default("2d") // "2d" | "3d" - generation mode
  artStyle            String?
  baseResolution      String?
  perspective         String?
  gameGenre           String?
  theme               String?
  mood                String?
  colorPalette        String?
  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt
  memoryFiles         MemoryFile[]
  styleAnchors        StyleAnchor[]
  generatedAssets     GeneratedAsset[]
  characterRegistry   CharacterRegistry[]
  generationCosts     GenerationCost[]
  generated3DAssets   Generated3DAsset[]
}

// MemoryFile model - stores JSON content like entities.json, conversation history
model MemoryFile {
  id        String   @id @default(uuid())
  projectId String
  project   Project  @relation(fields: [projectId], references: [id])
  type      String
  content   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@unique([projectId, type])
}

// StyleAnchor model - reference image and style keywords for consistent generation
model StyleAnchor {
  id                   String   @id @default(uuid())
  projectId            String
  project              Project  @relation(fields: [projectId], references: [id])
  referenceImageName   String
  referenceImageBlob   Bytes    @db.ByteA  // PostgreSQL bytea type
  referenceImageBase64 String?  @db.Text
  styleKeywords        String
  lightingKeywords     String
  colorPalette         String   @db.Text // Stored as JSON string
  fluxModel            String
  aiSuggested          Boolean  @default(false)
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
}

// CharacterRegistry model - tracks character descriptions, colors, successful seeds
model CharacterRegistry {
  id                   String   @id @default(uuid())
  projectId            String
  project              Project  @relation(fields: [projectId], references: [id])
  name                 String
  baseDescription      String
  colorHex             String   // Stored as JSON string
  styleKeywords        String
  successfulSeed       Int?
  posesGenerated       String   // Stored as comma-separated or JSON
  animations           String   // Stored as JSON string
  // Reference direction for multi-directional consistency
  referenceDirection   String?  // e.g., "south", "north", "east", "west"
  referenceImageBase64 String?  // Base64 of first-generated direction (replaces style anchor)
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
}

// GeneratedAsset model - stores metadata only (images in IndexedDB)
model GeneratedAsset {
  id         String   @id @default(uuid())
  projectId  String
  project    Project  @relation(fields: [projectId], references: [id])
  assetId    String
  status     String
  seed       Int?
  // imageBlob removed - images stored in browser IndexedDB
  metadata   String?  // Stored as JSON string
  promptUsed String?
  variantId  String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
}

// GenerationCost model - tracks actual costs from OpenRouter
model GenerationCost {
  id               String   @id @default(uuid())
  projectId        String
  project          Project  @relation(fields: [projectId], references: [id])
  generationId     String   @unique // OpenRouter generation ID
  modelId          String
  totalCost        Float
  promptTokens     Int?
  completionTokens Int?
  imageCount       Int      @default(1)
  metadata         String?  // Additional usage details as JSON
  createdAt        DateTime @default(now())
}

// Generated3DAsset model - tracks 3D asset generation pipeline
// Stores task chain IDs and model URLs from Tripo3D API
model Generated3DAsset {
  id                String   @id @default(uuid())
  projectId         String
  project           Project  @relation(fields: [projectId], references: [id])
  assetId           String   // Original asset ID from plan
  name              String?  // Human-readable asset name for file naming (e.g., "Knight Character")
  status            String   // queued | generating | rigged | complete | failed

  // Tripo task chain IDs
  draftTaskId       String?
  rigTaskId         String?
  animationTaskIds  String?  // JSON: {"walk": "task-123", "idle": "task-456"}

  // Model URLs from completed tasks
  draftModelUrl     String?
  riggedModelUrl    String?
  animatedModelUrls String?  // JSON: {"walk": "url", "idle": "url"}

  // Generation metadata
  promptUsed        String   @db.Text
  fullPrompt        String?  @db.Text
  isRiggable        Boolean?
  errorMessage      String?

  // Approval workflow fields
  approvalStatus    String?   // 'pending' | 'approved' | 'rejected'
  approvedAt        DateTime? // Timestamp when approved

  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@unique([projectId, assetId])
}

// =============================================================================
// HATCH STUDIOS MODELS
// Game creation platform with AI-assisted code generation
// =============================================================================

// Game model - main entity for a Hatch Studios game project
model Game {
  id              String            @id @default(uuid())
  userId          String
  user            User              @relation(fields: [userId], references: [id])
  name            String
  description     String?
  // Note: activeSceneId is NOT a FK to avoid circular dependency issues
  // Validation that it belongs to this game is done in API layer
  activeSceneId   String?
  phase           String            @default("planning") // 'planning' | 'building' | 'testing'
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  deletedAt       DateTime?         // Soft delete support
  scenes          GameScene[]
  codeVersions    CodeVersion[]
  assetRefs       GameAssetRef[]
  chatMessages    GameChatMessage[]
  files           GameFile[]
  plan            GamePlan?
}

// GamePlan model - stores the AI-generated game plan (markdown)
// Created during planning phase, referenced during building phase
model GamePlan {
  id          String   @id @default(uuid())
  gameId      String   @unique
  game        Game     @relation(fields: [gameId], references: [id], onDelete: Cascade)
  content     String   @db.Text  // Markdown plan content
  status      String   @default("draft") // 'draft' | 'accepted' | 'rejected'
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

// GameFile model - individual code files within a game (multi-file support)
// Files are executed in orderIndex order when rendering the game
model GameFile {
  id          String   @id @default(uuid())
  gameId      String
  game        Game     @relation(fields: [gameId], references: [id], onDelete: Cascade)
  name        String   // Filename: "main.js", "player.js", "enemies.js"
  content     String   @db.Text
  orderIndex  Int      @default(0) // Execution order (0 = first)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([gameId, name]) // No duplicate filenames in a game
  @@index([gameId, orderIndex])
}

// GameScene model - individual scene within a game
// Note: With multi-file support, scene.code is deprecated in favor of GameFile
model GameScene {
  id         String           @id @default(uuid())
  gameId     String
  game       Game             @relation(fields: [gameId], references: [id], onDelete: Cascade)
  name       String
  orderIndex Int              @default(0)
  code       String           @db.Text // Deprecated: use GameFile instead
  createdAt  DateTime         @default(now())
  updatedAt  DateTime         @updatedAt
  placements AssetPlacement[]
}

// CodeVersion model - version history for game code (per-file snapshots)
model CodeVersion {
  id          String   @id @default(uuid())
  gameId      String
  game        Game     @relation(fields: [gameId], references: [id], onDelete: Cascade)
  fileName    String?  // Which file this version is for (null = legacy single-file)
  code        String   @db.Text
  description String?
  trigger     String   // 'user_save' | 'ai_generation' | 'auto_save' | 'createFile' | 'updateFile'
  createdAt   DateTime @default(now())

  @@index([gameId, createdAt])
}

// GameAssetRef model - links external assets to a game
model GameAssetRef {
  id             String           @id @default(uuid())
  gameId         String
  game           Game             @relation(fields: [gameId], references: [id], onDelete: Cascade)
  assetProjectId String           // Original project the asset came from
  assetId        String           // Asset ID within that project
  assetType      String           // 'model' | 'texture' | 'skybox' | etc.
  name           String
  thumbnailUrl   String?
  glbUrl         String?
  createdAt      DateTime         @default(now())
  placements     AssetPlacement[] // Relation: all placements of this asset

  @@unique([gameId, assetId])
}

// AssetPlacement model - positions an asset within a scene
model AssetPlacement {
  id         String       @id @default(uuid())
  sceneId    String
  scene      GameScene    @relation(fields: [sceneId], references: [id], onDelete: Cascade)
  assetRefId String
  assetRef   GameAssetRef @relation(fields: [assetRefId], references: [id], onDelete: Cascade)
  positionX  Float        @default(0)
  positionY  Float        @default(0)
  positionZ  Float        @default(0)
  rotationX  Float        @default(0)
  rotationY  Float        @default(0)
  rotationZ  Float        @default(0)
  scaleX     Float        @default(1)
  scaleY     Float        @default(1)
  scaleZ     Float        @default(1)
  createdAt  DateTime     @default(now())
  updatedAt  DateTime     @updatedAt
}

// GameChatMessage model - AI chat history for game context
model GameChatMessage {
  id        String   @id @default(uuid())
  gameId    String
  game      Game     @relation(fields: [gameId], references: [id], onDelete: Cascade)
  role      String   // 'user' | 'assistant' | 'system'
  content   String   @db.Text
  toolCalls String?  @db.Text  // JSON of tool calls if assistant message
  createdAt DateTime @default(now())

  @@index([gameId, createdAt])
}
